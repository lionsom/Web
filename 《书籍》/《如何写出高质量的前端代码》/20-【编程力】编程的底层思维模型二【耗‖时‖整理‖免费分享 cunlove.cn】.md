逻辑思维
====

我们经常会听到这样的话："这块代码的逻辑可真复杂啊！"、"你这个产品设计不符合逻辑啊！"，"你这话讲的毫无逻辑可言"，"她干不了程序员，这个人逻辑思维能力不行"。

在我们的认知中，程序员必须具备较强的逻辑思维能力，逻辑思维能力差的是成不了优秀的程序员的，我相信大部分程序员对此都比较认同，但是如果我问你到底什么是"逻辑"，你能用一句话描述逻辑的内涵吗？我想大部分都很难准确地表达出来，而且想要完全搞明白逻辑是很难的，光《逻辑学导论》就有 752 页，本节内容我们只是初步带大家了解下逻辑学，并尽可能和前端开发联系起来。

认识逻辑思维
------

### 逻辑的来源与含义

逻辑（英语：logic）的字根来自（古希腊语：λογική，罗马化：logikḗ），意为：具有理由的、知识的、辩证的、论辩的；逻辑此词又与逻各斯（古希腊语：λόγος，罗马化：lógos）同源，意为：词语、思想、概念、理念、论据、论点、说明、理由、原则、推理。“logikḗ”此后译为法语：logique，再发展为英语的逻辑：logic。

“逻辑”源自于“逻各斯”（logos，其复数形式是logoi），其主要含义有：

1.  一般的规律、原理和规则。
2.  命题，说明，解释，论证等。
3.  理性，推理，推理能力，与经验相对的抽象理论，与直觉相对的有条理的推理。
4.  尺度，关系，比例，比率等。

“逻各斯”的基本词义是言辞、理性、秩序、规律，其中核心含义又是“秩序”和“规律”，其他含义都是由此派生出来的。例如，“有秩序的”、“合乎规律的”就是合乎“理性”的；“推理”就是按照“规律”进行有“秩序”的、有条理的思维。西方各门科学的词尾“学”字（-logy），均起源于“逻各斯”这个词，“逻辑”一词更是从它引申出来的。

“逻辑”的现代汉语词义为：

1.  客观事物的规律，例如：“历史的逻辑决定了人类社会将一直向前发展。”
2.  某种理论、观点，例如：“只许官家放火，不许百姓点灯，这是哪一家的逻辑！”
3.  思维的规律、规则，例如：“某个说法不合逻辑”。
4.  逻辑学或逻辑知识，例如“大学生应该上逻辑课”。

逻辑学是一种研究思维和推理规律的学科，它主要关注如何正确地推导出结论、判断命题的真假以及推理过程的有效性。

比如如果a > b, b > c，那么我们可以推出 a > c，再比如如果所有的哺乳动物都是胎生的，且鲸鱼是哺乳动物，那么我们可以推出鲸鱼也是胎生的。

我们经常说一个人说话没有逻辑，通常是指他所讲述的"前提条件"和他得出的"结论"之间没有"关系"。

比如我媳妇经常给我说的一句话，"你要把房间收拾干净，因为房间干净才能招财"，我认为这句话就是没有逻辑的，因为"房间干净"和"招财"之间没有必然关系，我把用来学习的时间都用来收拾房间，难道就会让我变的富有吗？我反而觉得如果都把时间都花在这些琐事上，才会影响我招财。

有一天我实在忍不住了，我就问她"房间干净和招财有什么逻辑关系"，她说"房间不干净会让我心情不好，我心情不好就会找你麻烦，找你麻烦就耽误你搞事业，耽误搞事业就影响赚钱，所以房间干净了会招财"，我去，原来房间干不干净和招财之间还有这层关系，我瞬间觉得逻辑自洽了。

所以我们也可以在某些场景下将逻辑简单地理解为"关系"，事物之间没有逻辑就是缺少正确的关系。

### 什么是逻辑思维

逻辑思维是人们在认识过程中借助于**概念、判断、推理**反映现实的过程。它与形象思维不同，是用科学的抽象概念、范畴揭示事物的本质，表达认识现实的结果。逻辑思维是一种确定的，而不是模棱两可的；前后一贯的，而不是自相矛盾的；有条理、有根据的思维；在逻辑思维中，要用到**概念、判断、推理**等思维形式和**比较、分析、综合、抽象、概括**等方法，而掌握和运用这些思维形式和方法的程度，也就是逻辑思维的能力。

在上面的定义中，我们可以看到逻辑思维包含3个要素：概念、判断和推理。

### 概念

概念是反映对象特有属性或本质属性的思维形式。概念是词语的思想内容，概念的存在需要依赖于词语，词语是概念的表现形式，同一个概念可以用不同的词语表达。概念具有内涵和外延两个属性，内涵是反映概念中的对象的特有属性或本质属性，就是回答事物是什么样的，外延是指具有概念所反映的特有属性或本质属性的对象，就是回答这类事物有哪些，这在抽象思维一节我们已经有过详细介绍。

无论是编写代码、讨论问题还是学习一门课程，第一件事就是要搞明白概念，如果概念的内涵理解不一致，大家讨论时就如同鸡同鸭讲，完全不在一个频道上，很多争论都是因为大家对概念的理解不一致造成的。

生活中男女朋友经常会因为对"爱"的理解不一致而产生口角。

> 女：你爱我吗？天天也不陪我！ （爱是陪伴）
> 
> 男：我怎么不爱你，为了给你好的生活条件，我天天起早贪黑，早出晚归的，我容易吗？！（爱是给予好的生活条件）

在编程时，对概念的理解是非常重要的，否则就会产生bug，比如对于一个电商网站，领导让统计本月的销售金额，如果大家对本月销售金额的概念理解不一致，那么统计的结果就会不一样。

*   本月销售金额是指创建时间在本月的订单金额，还是付款时间在本月的订单金额？如果订单是6月29日产生的，却在7月2日付款，这笔订单算哪个月的销售金额？
*   销售金额包含已退款的订单吗？

如果你需要开发这块代码，你的第一件事是什么？肯定是要先搞清楚概念，搞明白到底什么叫"本月订单金额"，定义问题有时比解决问题还要重要。

再举个前端开发中经常遇到的例子，比如我们要开发一个表单，表单中有个\*\*有效期，需要录入开始日期和结束日期，产品经理要求有效期最长为1个月，如果开始时间用户选择的是1月31日，那么结束日期最大允许用户选择到哪一天？2月28日？还是3月1号？就算选择的是2月28日，那是不是包含了一个完整的月（2月）加1天（1月31日那天）呢？那这不就不是一个月了吗？这里"月"的概念到底是什么呢？所以如果概念都定义不清楚，那么怎么进行代码开发呢？

所以在前面的内容中，多次建议团队制定一套领域词汇表，将业务中的每个概念定义清楚，并统一变量命名。

### 判断

判断是一个逻辑学名词，用于对思维对象是否存在、是否具有某种属性以及事物之间是否具有某种关系的肯定或否定，它构成了推理的基本单位，在形式逻辑上，判断通常用一个命题表达出来。

判断有两条基本特征：

*   判断必须对事物的情况有所断定，即有所肯定或否定。
*   判断有真假之分，其真假取决于是否符合客观实际情况。

判断的分类：

*   简单判断：本身不包含其他判断的判断，例如“苹果很甜”或“0小于1”。
    *   性质判断（直言判断）：断定事物具有或不具有某性质的判断，如“雪是白的”。
    *   关系判断：断定事物与事物之间的关系的判断，如“叶问和李小龙是师徒”。
*   复合判断：自身包含其他判断的判断，例如“如果明天下雨，我就不出门”。
    *   假言判断（条件判断）：断定一事物情况是另一事物情况存在的条件的判断，如“如果我能预知明天，那么我的每期彩票都能中奖”。
    *   选言判断：断定若干种可能的事物情况有一种存在的判断，如“小明或者精通英语，或者精通日语”。
    *   联言判断：断定事物的若干种情况同时存在的判断，如“小明参加过拔河比赛，也参加过篮球比赛”。
    *   负判断：否定某个判断的判断，如“并非这种商品质量好”。

### 推理

所谓推理就是一种基于已知信息或前提，通过逻辑规则推导出新结论的思维过程。常见的逻辑推理有演绎推理、归纳推理和溯因推理。

#### 演绎推理

所谓演绎推理，就是从一般性的前提出发，通过推导即“演绎”，得出具体陈述或个别结论的过程。

例如"所有人都会死，苏格拉底是一个人，因此苏格拉底会死"，这里"所有人都会死"是大前提，是一个已知的一般原理，"苏格拉底是一个人"是小前提，是大前提中的一个特定情况，由此可以推出结论"苏格拉底会死"，这就是一个经典的三段论演绎推理形式。

![jiegou-luoji-sanduanlun1.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bcd63c8bf2cc4fa788aeca11002b3747~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=856&h=186&s=31503&e=png&b=ffffff)

三段论推理的结构如下：

*   大前提：一个普遍性的陈述，作为推理的出发点，通常是一个全称命题或普遍性原理。
*   小前提：一个关于特定情况的陈述，作为推理的第二个前提，通常是一个特殊命题或特定事实。
*   结论：由大前提和小前提通过逻辑推导得出的必然结果。

这种方式在数学中经常可以见到，比如平行四边形的对角线互相平分，菱形是平行四边形，菱形的对角线互相平分；三角形内角和为180°，直角三角形也是三角形，所以直角三角形的内角和为180°。

演绎推理在生活中也经常用到，比如所有女人都爱花，女朋友是女人，所以送给她花一定没错；所有程序员都需要具备良好的逻辑思维能力，前端开发是程序员，所以前端开发必须要努力提升自己的逻辑思维能力。

在使用演绎推理时要注意，演绎推理要求大、小前提的判断必须是真实的正确的，如果大前提错了，结论自然也不会正确。

用个前端实际编程中树的叶子节点的判断为例，"所有叶子节点都没有children字段，如果一个子节点没有children字段，那么它就是叶子节点"，这里我们来看下这个大前提是否正确，很明显有遗漏，一个节点有children字段，但children长度为零也属于叶子节点，所以如果你按照上面的大前提去推理，结果肯定是错误的。

#### 归纳推理

归纳推理是一种从个别到一般的推理方法，它通过观察和分析特定情况下的具体事例或现象，从而推导出一般性的结论或规律。归纳推理与演绎推理正好是反向的。

例如：在一个平面内，直角三角形内角和是180度；锐角三角形内角和是180度；钝角三角形内角和是180度；直角三角形，锐角三角形和钝角三角形是全部的三角形；所以，平面内的一切三角形内角和都是180度。

使用归纳法最大的问题就是，归纳法很难穷举所有可能的情况，所以无法得到真理。比如我们看到很多天鹅都是白的，使用归纳法可以得出天鹅是白色的结论，但只要发现一个黑色的天鹅，这个结论就错了。

虽然归纳法有这个缺点，但归纳法可以产生新的知识，可以帮助我们更好地认识世界，比如我们对人性的认识，我们肯定无法对地球上各个地方以及过去和未来的所有人进行归纳，分析每个人的特点，但是我们通过对一些样本的分析，能够发现一些人性的基本特点，这对人与人之间的交流、协作等还是非常有指导意义的。

在前端开发中，组件抽取可以视为归纳法的一种应用，前端开发会观察多个页面或功能区块的相似性和共通性，然后将这些共通的部分抽象成独立的组件。这个从具体实现中归纳出共性的过程，正是归纳法在组件抽取中的体现。

而在提取出公共组件后，又可以反过来分析在多个不同场景下是否仍然满足需求，这种从一般到到特殊的过程，又是演绎推理的一种体现，所以在实际工作中，归纳法和演绎法经常会同时使用，而且可能经过多次这样的反复推演，才能得到比较满意的组件设计。

#### 溯因推理

溯因推理，也译作反绎推理、反向推理，是美国汉森提出的术语，其原词在古希腊亚里士多德那里初步提出时译为还原，美国皮尔斯则译为逆因或回溯。溯因推理是指从已知的结果出发，反向推导出可能的原因或解释的过程。

如果做到这一点呢，可以参考科学研究中的一个重要方法：大胆假设，小心求证。

比如公司网站突然访问速度变慢了，那我们首先猜测是不是我电脑的网速变慢了，可以试着访问一个别的网站看看，如果别的网站速度都正常，那继续猜测是不是因为某个接口卡住了，打开控制台查看果然鉴权接口响应速度非常慢，然后接着猜测是不是今天有人更新这个接口实现了，群里询问了下，果然是某个同事今天修改了鉴权接口，那么就可以让这个后端同事去排查接口代码问题了。

在溯因推理时，尤其应该注意，需要多问几个为什么来找到问题的根本原因，否则就是指标不治本。比如你经常头疼，庸医的解决方案可能就是直接吃止疼药，而一个好的医生则可能试图去找到病根，首先可能会检查为什么头疼，发现是脑部供血不足，为什么脑部供血不足呢，发现存在颈椎病，为什么存在颈椎病呢，因为总是长时间对着电脑，到这里医生可能会建议你平时工作1个小时左右出去活动活动，这样才可能去除头疼的病根。而对于我们自己还可以继续追问几个为什么，为什么我总是长时间对着电脑不活动呢，因为我总想赶紧把事情搞完，为什么总想赶紧把事情搞完呢，因为我怕没搞完会受到领导批评，最后头疼的问题可能是要通过调整心态来彻底解决，而不是吃药。

![jiegou-luoji-5why.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cad9592d4133450e82d32ad319da45d1~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=764&h=362&s=56815&e=png&b=ffffff)

在寻找问题根源时，有个很重要的分析方法，称为5Why分析法，也被称为“5问法”，是一种通过连续提问五个为什么来追究问题的根本原因的分析方法。5Why分析法的目的是确保对问题的理解不仅仅停留在表面，而是要挖掘出导致问题的真正原因，从而采取有效的对策，防止问题再次发生。

关于5Why分析法有个经典案例，话说有一次丰田汽车公司工厂设备停机了，在寻找停机原因时当时的副社长大野耐一进行了连续5次追问。

> 为什么机器停机？因为机器超载，保险丝烧断了。
> 
> 为什么机器超载？因为轴承的润滑不足。
> 
> 为什么轴承润滑不足？因为润滑泵失灵了。
> 
> 为什么润滑泵失灵？因为它的轮轴耗损了。
> 
> 为什么轮轴耗损？因为杂质跑到里面去了。

通过这五次追问，大野耐一找到了问题的真正原因，即在润滑泵上加装滤网以防止杂质进入。这个例子展示了5Why分析法在追根溯源、找到问题根本原因方面的强大作用。

5Why分析法在工作生活中都可以用到，前端开发也不例外，比如我们发现每次上线后用户那边都会报错，排查发现是用户那边存在缓存，普通的前端开发可能会说"清一下缓存试试"，而优秀的前端可能会问自己"为什么会存在缓存？"，排查发现原来是html文件设置了强制缓存，导致入口文件没有及时更新，为什么设置了这个错误的缓存策略却没有被提前发现呢？原来是缺少 CodeReview机制，优秀的前端开发不仅彻底解决了上线后的缓存问题，可能还会对团队的协作流程进行一些优化。

逻辑思维在前端开发中的运用
-------------

逻辑思维可以说在工作和生活中无处不在，大到战略制定，小到一行代码的编写，都离不开逻辑思维，这里只列举几个我觉得重要的场景。

*   重视概念的作用

一定要对业务开发中的概念有清晰的认识，明确每个概念的定义，当发现大家就一个问题产生争论时，首先要想想大家说的是同一个概念吗？一定要先定义问题，然后再讨论怎么解决问题。

*   彻底解决问题

通过5Why分析法，找到bug的深层次原因，从根本上解决问题。

*   审视需求的合理性

面对需求时，多想一想为什么要设计这个功能？其深层次原因是什么？该功能能很好地解决这个问题吗？有没有更好的方案？或者这个需求的前提条件是正确的吗？推演下在不同场景下用户可能的反应。

*   组件、方法抽取

通过归纳推理，找出不同场景下共性的部分，抽取成独立的组件或方法。

*   避免逻辑遗漏

在写代码时，确保逻辑是完整的，分析每个操作可以进行的前置条件是什么？可能的结果有哪些？确保代码覆盖到每一个可能的场景。

分治思维
====

在你当年还是前端菜鸟的时候，如果让你直接负责一个系统的前端开发，你会不会觉得太难了，不知道自己究竟能不能按时完成；那如果让你负责一个独立的模块呢，是不是觉得虽然很难，但是勉强还能胜任；而如果分给你一个页面甚至是一个小组件呢，是不是就感觉很轻松了。的确，任务越庞大，解决起来就越困难，任务越小，解决起来就越轻松，这就是分治的力量。

将一个庞大的看似不可能完成的任务，通过分治思维将其拆分成一个一个的易执行的小任务，然后逐个击破，最终让我们完成了之前感觉不可能完成的任务，实现自我的突破，这就是我们学习分治思维的目的。

认识分治思维
------

所谓分治，字母理解就是分而治之，其核心思想是将一个复杂的问题分解成两个或多个较小的、相似的子问题，递归地解决这些子问题，然后将子问题的解合并起来，从而解决整个问题。这种策略在算法设计和计算机科学中非常常见，也是许多高效算法的基础，如归并排序、快速排序、大整数乘法等。

![jiegou-fenceng-fenjiehebing.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b24766fa0094825bed47c9b6886361a~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=655&h=349&s=45705&e=png&b=ffffff)

分治思维的基本步骤如下：

*   分解：将原问题分解成若干个规模较小、相互独立、与原问题形式相同的子问题。
*   解决：递归地解决这些子问题。如果子问题的规模足够小，则直接求解。
*   合并：将子问题的解合并成原问题的解。

通过"分解--解决--合并"就能较容易的完成大型或者复杂问题的处理，所以当你面对的问题较大时，第一个要想起来的就应该是分而治之。

分治思维不只是用来解决工作生活中的复杂问题，在各行各业都有应用，大到国家的治理，小到团队的管理都离不开分治，假如你没有太多管理经验，有一天运气爆棚了，领导让你管一个几十人的团队你怎么办？最简单的办法就是按照特定的职责将团队分拆为几个小组，你只需要管理3-5个小组长即可。

分治思维在前端开发中的运用
-------------

分治思维在编程中应用非常广泛，包括不限于算法设计、开发模式设计、组件化/模块化开发等，到处都有分治的身影。

### 分治思想在算法中的应用

#### 递归

相信有的同学已经感受到了，分治思想解决问题的过程和递归的处理过程是完全一致的，都是先把一个大问题拆成一个一个的小问题，如果小问题还是比较复杂就继续拆分，直到小问题足够小，可以直接求解，然后再把求解结果逐步向上传递，最终完成最初的大问题。

以树的前序遍历为例，所谓前序遍历就是首先访问树的根节点，然后遍历树的左子树，最后遍历右子树（对于二叉树而言），对于更一般的树而言，就是遍历根节点的所有子节点；而子节点还可能是一个树结构，没关系，依然对其进行前序遍历，直到子节点是一个叶子节点。树的其他遍历和前序遍历思路一致，区别仅仅为根节点的访问顺序。

    //树节点结构
    function TreeNode(value) {  
        this.value = value;  
        this.children = [];  
    }
    
    //先序遍历
    function preorderTraversal(node) {
      if (node) {
        console.log(node.value); // 访问根节点  
        node.children.forEach(child => preorderTraversal(child)); // 递归遍历所有子节点  
      }
    }
    
    //后序遍历
    function postorderTraversal(node) {
      if (node) {
        node.children.forEach(child => postorderTraversal(child)); // 递归遍历所有子节点  
        console.log(node.value); // 最后访问根节点  
      }
    }
    
    //中序遍历
    function inorderTraversal(node) {
      if (node) {
        inorderTraversal(node.left); // 遍历左子树  
        console.log(node.value); // 访问根节点  
        inorderTraversal(node.right); // 遍历右子树  
      }
    }
    
    // 注意：上面的TreeNode定义对于二叉树来说，需要稍作修改以包含left和right属性。  
    function TreeNodeBinary(value) {
      this.value = value;
      this.left = null;
      this.right = null;
    }
    

#### 动态规划

说到递归，就自然要说到动态规划，递归和动态规划的思路是差不多的，只是解题流程有区别，递归是大问题的求解直接依赖子问题的求解，子问题再依赖子问题，依次传递下去，然后最小的子问题得到结果后再依次向上传递，这个过程就会存在同一个子问题被反复求解的情况，导致性能较差；而动态规划则是先对最小的子问题进行求解，然后逐步推导出大问题，不会存在重复计算子问题的情况，相当于带有备忘录的递归。

动态规划的分析仍然需要分治思想，其核心就是找到一个大问题与一个或多个小问题之间的关系，也就是转移方程，只要找到了这个关系，我们就可以从最小的问题出发（小问题直接给出结果），逐步推导出大问题的结果。

以爬楼梯为例：

> 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
> 
> 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

首先我们用f(n)代表爬到第 n 级台阶的方案数，f(n)可以看做是一个大问题，那它和更小的问题有什么关系呢？经过分析我们可以知道，到达n级台阶只有两种方案：一种是在 n-1 阶爬1个台阶，一种是在 n-2 阶爬2个台阶，所以我们可以得到 f(n) = f(n-1) + f(n-2)，得到这个转移方程，我们就有能力将大问题的求解转化为更小问题的求解。

![jiegou-fenzhi-palouti.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5381e807ae2149a49b20a81e5a3f4f1b~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=936&h=279&s=27371&e=png&b=ffffff)

也就是我们只要知道了 f(1)和f(2)，就能知道f(3)，知道了f(3)就能知道f(4)...，为了让这个循环跑起来，我们只需要找到f(1)和f(2)的值即可，初始值可以通过分析直接求解。

> 爬到第一层台阶只有1种方法：直接爬1层，所以 **f(1) = 1**
> 
> 爬到第2层台阶只有2种方法：直接爬2层或者连续爬1层，所以 **f(2) = 2**

有了初始值之后，解答过程就非常简单了，实现如下：

    var climbStairs = function(n) {
        let dp = new Array(n+1).fill(0);
        dp[1] = 1;
        dp[2] = 2;
        if(n <= 2){
            return dp[n];
        }
        for(let i = 3; i <= n; i++){
            dp[i] = dp[i-1] + dp[i-2];
        } 
        return dp[n]; 
    };
    

#### 归并排序

归并排序（Merge Sort）是一种分而治之的排序算法。它将原始数组切分成较小的数组，直到每个小数组只有一个位置，接着将小数组归并成较大的有序数组，直到最后只有一个排序完毕的数组。归并排序的关键在于“归并”两个已排序的序列。

    function mergeSort(arr) {  
        if (arr.length < 2) {  
            // 基本情况，数组只有一个或没有元素时，直接返回数组  
            return arr;  
        }  
      
        // 找到中间位置，将数组分成两部分  
        const middle = Math.floor(arr.length / 2);  
        const left = arr.slice(0, middle);  
        const right = arr.slice(middle);  
      
        // 递归地对左右两部分进行归并排序  
        return merge(mergeSort(left), mergeSort(right));  
    }  
      
    function merge(left, right) {  
        let result = [];  
        let leftIndex = 0;  
        let rightIndex = 0;  
      
        // 当左右子数组都不为空时，将较小的元素添加到结果数组中  
        while (leftIndex < left.length && rightIndex < right.length) {  
            if (left[leftIndex] < right[rightIndex]) {  
                result.push(left[leftIndex]);  
                leftIndex++;  
            } else {  
                result.push(right[rightIndex]);  
                rightIndex++;  
            }  
        }  
      
        // 将左子数组剩余的元素添加到结果数组中  
        while (leftIndex < left.length) {  
            result.push(left[leftIndex]);  
            leftIndex++;  
        }  
      
        // 将右子数组剩余的元素添加到结果数组中  
        while (rightIndex < right.length) {  
            result.push(right[rightIndex]);  
            rightIndex++;  
        }  
      
        return result;  
    }  
      
    // 使用示例  
    const array = [38, 27, 43, 3, 9, 82, 10];  
    console.log("Original array:", array);  
    console.log("Sorted array:", mergeSort(array));
    

分治思想在算法中还有很多应用，比如快速排序、二分查找、大整数运算、快速傅里叶变换等等，这里不再赘述。

### SPA、MonoRepo、微前端

前端开发模式的演进也是分治思想的一种体现，在项目初期，我们可能只是采用最简单的SPA（Single Page Application，单页面应用程序）模式进行开发，但是随着需求越来越多，项目越来越复杂，最终可能变成了"巨石"应用，带来很多缺点：

*   编译、打包速度超慢
*   打包文件过大，加载速度慢
*   每个模块都高度耦合在一起，一个模块出问题可能会影响整个项目
*   一个模块的修改可能需要重测整个项目
*   新人上手难度较大，需要熟悉的内容太多，且多人协作很容易冲突
*   不灵活，不能根据需要只部署某几个模块
*   技术栈无法更换，时间越久更换的成本越高，难度越大

为了解决这个问题，目前一般可以采用两种方式：MonoRepo和前端微服务。

#### MonoRepo

在对大型系统进行拆分时，需要将一个系统分成多个项目，而MonoRepo（单一代码仓库）模式就是通过一个代码仓库来管理这些拆分后的项目，而不是把多个项目分散在多个独立的代码仓库中。

这种管理方式有助于简化代码共享、版本控制、构建和部署等方面的复杂性，并提供更好的可重用性和协作性。试想一下，如果多个项目之间需要复用同一个业务组件，它们又不在一个代码仓库你能怎么办？是不是只能通过发布npm包进行共享了，这就增加了复用的门槛。

大多数复杂的前端库都是采用这种方式来开发，通常我们会在库中看到一个名为packages的文件夹，其中就是一个一个独立的小项目，每个小项目都有自己的package.json，可以独立打包。

![jiegou-fenzhi-packages.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08b5e51165574551908c13e2539725ca~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=841&h=735&s=289628&e=png&b=0e1218)

MonoRepo这种方式实现起来比较简单，有很多方案可选择，如Yarn Workspaces、pnpm、Lerna、turbo等，而且因为所有项目都在一个仓库中，很方便同时对多个项目进行修改，其构建和部署过程也更加简单和高效，MonoRepo正逐渐成为开发团队的新宠。

#### 微前端

以qiankun为代表的微前端开发方案，这几年也变的越来越普及，大家或多或少都接触过。

微前端借鉴了微服务的架构理念，将一个庞大的前端应用拆分为多个独立灵活的小型应用（即微应用），每个应用都可以独立开发、独立运行、独立部署，再将这些小型应用联合为一个完整的应用，这和我们前面提到的分治思想是完全一致的。

采用微前端技术有以下优点：

*   技术栈无关：主框架不限制接入应用的技术栈，子应用可自主选择技术栈。
*   独立开发/部署：各个团队之间仓库独立，单独部署，互不依赖。
*   增量升级：当一个应用庞大之后，技术升级或重构相当麻烦，而微应用具备渐进式升级的特性。
*   独立运行时：微应用之间运行时互不依赖，有独立的状态管理。
*   提升效率：应用越庞大，越难以维护，协作效率越低下。微应用可以很好拆分，提升效率

相较于MonoRepo方案，微前端更加灵活，它不要求必须采用同一个仓库，多个团队之间可以进行更加灵活的协作，各自管理各自的仓库，最后只把产出集成到一起即可，但同时也会增加一些成本，毕竟每个子项目都要进行一定的改造。

#### 如何选择

MonoRepo和微前端都比较适合大型项目的开发，而且也都各有优缺点，那如何选择呢？这里给大家一个思路，就是参考康威定律。

康威定律的核心思想是：“设计系统的架构受制于产生这些设计的组织的沟通结构。” 通俗地讲，产品必然是其（人员）组织沟通结构的缩影。这一定律在软件架构设计中尤为显著，它揭示了组织架构和沟通模式对系统设计的重要影响。

如果多个项目背后对应着多个前端团队，那么建议采用微前端的方式，每个项目采用各自独立的仓库，而如果多个项目背后都是同一个前端团队，那MonoRepo可能更适合你们，总之软件开发没有银弹，适合的才是最好的。

### 组件化/模块化开发

分治思维在前端最直观的体现就是组件化/模块化开发，通过这种思想，将一个复杂的页面拆分成一个个小组件，每个组件只负责特定的功能或展示，通过组件化开发，可以提高代码的可维护性和复用性，降低开发成本。

关于如何开发一个好的组件，前面我们有专门的一节内容，这里不再赘述。

这里要提醒大家的是，当我们遇到一个复杂的功能模块时，不要害怕，试着先将其进行拆解，拆解后的小模块复杂度相对来说就会变小，开发起来也相对容易，等所有小模块开发完成，大功能也基本成型，再搭配着重构，对模块进行更加合理的拆分。

分层思维
====

相信大部分同学都听过或者接触过MVC架构，在前些年还没有流行三大框架的时候，普遍采用的就是MVC架构的网站开发，比如JAVA语言的Spring框架、Struts、JSF以及PHP语言的Laravel、Symfony、Yii等，都实现了MVC设计模式。

MVC（Model-View-Controller）是一种软件设计模式，它将应用程序分为三个层次：模型（Model）、视图（View）和控制器（Controller）。

*   视图层（View）：负责显示数据并将用户的输入传达给控制器，主要面向用户
*   控制器层（Controller）：控制器是MVC架构中的协调者，从View层接收数据传给Model层存储，或者从Model层获取数据传给View层展示。
*   模型层（Model）：复杂数据的处理和存储，主要面向数据库

![jiegou-fenceng-mvc.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afe493c9f85e4263bd6a02eae4b67ed8~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=523&h=529&s=32859&e=png&b=ffffff)

通过这种方式实现了应用程序的模块化、提高了开发效率、降低了维护成本，并促进了代码的复用性和可测试性。

MVC模式体现的就是分层思维，在IT中，分层的思想应用广泛且作用巨大，比如熟知的网络7层协议、TCP/IP四层模型等，接下来我们就讨论下分层思维。

认识分层思维
------

分层是一种组织和管理复杂系统或过程的方法，通过将系统或过程划分为一系列相互关联但独立的层次或层级，以简化其复杂性和提高可管理性。每个层次或层级都负责特定的功能或任务，并通过定义明确的接口或协议与其他层次进行交互。

![jiegou-fenceng-zongxaingfenceng.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4835ac533a6b421e99ee58700729d62b~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=383&h=357&s=16756&e=png&b=fefefe)

上面提到的MVC架构就是将用户与数据库交互的过程进行了拆分，OSI 7层协议是对网络通信过程进行的分层，所以如果你遇到一个特别复杂的**过程**，就可以试着通过分层去简化它的处理。

通过分层可以带来很多好处：

*   降低复杂性：通过将系统划分为较小的、更易于管理的部分，可以降低整体的复杂性，这分层其实也是分治的一种特例。
    
*   分离关注点：分层实际就是分离关注点，无论是阅读代码还是修改代码，只需要关注特定层的实现，而不用把注意力放到无关的层次上，这会提升代码可读性和可维护性。
    
*   提升复用性：因为每个层的职责比较单一，更容易复用
    
*   增强可扩展性：当需要扩展系统功能时，可以在不影响其他层次的情况下，在特定层次上添加新的功能或组件，也可以很方便地替换掉某个层，不会对整个系统造成大的改动，只会影响到相邻层次。
    

分层思维在前端开发中的应用
-------------

### 组件分层

在如何组织一个清晰的项目结构一节，我们就提到过，项目中的组件是应该有明确的层次结构的：

*   通用组件：和业务无关的基础组件，比如ElementUI这类的组件
*   项目基础组件：不局限于具体业务，比如根据公司的UI规范抽取出来的通用组件
*   业务组件：含有业务属性的组件，比如添加用户弹窗组件
*   页面组件：页面组件和路由一一对应，页面组件将业务组件进行组合，从而构成一个完整的可供用户使用的页面。

![conponent_level.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02dd13ff59ed4d70a9b20bb96ad5701d~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=868&h=241&s=42775&e=png&b=fefefe)

对组件进行分层非常重要，在开发一个组件时，首先就要清楚这个组件属于那一层，不同层次的组件有不同的要求，如果是项目基础组件，就不应该耦合业务逻辑，可以通过插槽等方式提升组件的扩展性，有的同学写的基础组件中就会通过各种分支判断来适配不同的业务场景，本质上就是没有想清楚组件的定位，心中没有分层的概念。

在组件进行分层后，组件的调用关系也变的更加简单明了，上层组件可以调用下层组件，但下层组件不能调用上层组件，这样也就避免了循环调用，很多项目中乱七八糟的组件调用关系，本质上也是因为没有分层。

### 样式分层

现在前端开发大都更重视JS或者组件层面的设计，往往忽略了项目中样式的设计，而样式设计也是前端开发中非常重要的一环，应该给予足够的重视。

项目中的Css样式实际也是存在一定的分层的：

*   重置样式：浏览器的很多默认效果可能不是我们需要的，在每个项目中你可能都需要对一些样式进行重置，那么就可以把这类样式沉淀起来，作为你个人开发项目时必备的一个最最基础的样式，类似normalize.css
    
*   主题变量：将项目的主题配置抽取为一个一个的CSS变量，上层样式设置时都引用这些变量，后续想要更换主题时，只需要修改变量值就可以，大大增强CSS样式的可维护性
    
*   组件库样式：一般我们都会引用一些第三方组件库的样式
    
*   项目通用样式：将项目中各页面通用的样式提取出来放到这一层，增强样式的复用性，不必每个页面进行重复设置；或者是对组件库的样式进行一些覆盖
    
*   组件样式：组件中特有的样式
    
*   页面样式：页面组件中特有的样式，可能是页面的布局样式
    

![jiegou-fenceng-css.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ab91b725b5b4118855d022d217da00f~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=368&h=384&s=27043&e=png&b=fefefe)

样式分层可以帮我们梳理清楚样式的优先级，顶层样式应该具有最高级别的优先级，上层样式可以覆盖下层样式，下层样式就不要动不动就采用"!important"的方式进行优先级的争夺，要给上层留有覆盖的机会。

### 复杂事件的处理

事件的处理其实就是一个过程，是过程我们就可以对其进行分层，虽然这里的分层没有多么的"惊天动地"，仅仅是对一个小小的处理流程进行拆分，不过也对我们代码的可读性和可维护性有不错的提升，好的项目质量不就这么一点一点积累来的嘛。

比如我们在点击"启动设备"按钮后，可能会进行启动前的各项检查、启动参数的准备、发起启动操作的请求，如果没有进行这种分层设计，可能的实现代码如下：

    function startDevice(device){
        if(device.status === 'running'){
            showToast('设备已经启动了，无法反复启动');
            return
        }else if(device.status === 'error'){
          showToast('设备故障，无法启动');
          return
        }
        if(!hasPermission('device', 'start')){
          showToast('无操作权限');
            return;
        }
        let body = {
            //准备设备启动的工艺参数
        };
        this.loading = true;
        deviceService.start(device, body).then(()=>{
            showToast('启动成功', 'success');
            refreshTable();
        }).catch(()=>{
          showToast('启动失败', 'error');
        }).finally(()=>{
            this.loading = false;
        })
    }
    

上面只是简化的代码，如果是比较复杂的业务，可能其中会有更多的细节，这样代码的可读性不强，无法很快知晓点击启动设备按钮到底都进行了哪些操作，而如果我们将启动过程分成了三层，每一层拆分成一个独立的函数，那么整个代码也更加架构化，结构非常清晰。

    function preCheck(device) {
      if (device.status === 'running') {
        showToast('设备已经启动了，无法反复启动');
        return false;
      } else if (device.status === 'error') {
        showToast('设备故障，无法启动');
        return false;
      }
      if (!hasPermission('device', 'start')) {
        showToast('无操作权限');
        return false;
      }
      return true;
    }
    
    function prepareData(device){
        return {
          //准备设备启动的工艺参数,忽略这块代码
        }
    }
    
    function start(device, data){
      this.loading = true;
      deviceService.start(device, body).then(()=>{
        showToast('启动成功', 'success');
        refreshTable();
      }).catch(()=>{
        showToast('启动失败', 'error');
      }).finally(()=>{
        this.loading = false;
      })
    }
    
    //点击启动设备对应的handler
    function startDevice(device) {
      //启动前检查
      if (preCheck(device)) {
        //准备请求数据
        let data = prepareData(device);
        //启动设备
        start(device, data);
      }
    }
    

有的同学可能会说，这么拆分后的代码比之前的代码还多呢，怎么能说提升了可读性呢？是这样的，我们看代码的时候往往是从入口文件开始，比如这个启动设备按钮的Click事件对应了startDevice函数，你肯定会先看startDevice函数，下面这个实现就可以让你很轻松地搞明白启动设备到底做了那几件事，而不像上面那种，你要阅读完所有的细节才能搞明白，所以可读性的高低和代码的多少关系不大。

### 复杂功能的开发

分层也是分治的一种，通过分层可以降低开发的复杂度，毕竟开发单独一个层次总比开发一个完整的项目要简单。

比如我们要开发一个pptx文件的预览功能，希望能够支持Canvas、Svg等多种渲染方式，如果不进行合理的分层，这肯定是非常难做的，而如果将整个预览过程进行合理的分层，则会简单很多。

我们可以将一个pptx文件的预览分为三层：文件解析层、渲染抽象层、渲染实现层：

*   文件解析层：这一层负责解析PPTX文件，将其内容（如幻灯片、文本、图片、形状等）转换成内存中的数据结构（如对象模型）。
*   渲染抽象层：定义渲染的接口或抽象类，包含渲染PPTX内容所需的基本方法（如渲染幻灯片、文本、图片等）
*   渲染实现层：具体实现渲染逻辑，包括Canvas渲染和SVG渲染。每个实现类对应一种渲染方式，并继承或实现渲染抽象层定义的接口。如实现CanvasRenderer、SVGRenderer

通过这种方式，将一个复杂的渲染过程拆解成可执行的三层，当然了，我们还可以对每一层继续利用分治思想进行拆解，进一步降低开发难度，这样就可以相对容易地完成这个复杂库的开发了。