前端要不要写单测，写到什么程度，这是一个比较有争议的话题，虽然明面上大家都会说单测很重要，但在实际执行时却又大打折扣，而更糟糕的情况是，工作了多年的前端开发者，甚至没有编写过一条自动化测试用例。

当然了写不写单测这事不单单是前端开发者的锅，和很多外部因素（领导的认知、公司的要求、排期的紧张程度等）都有很大关系，但是不可否认，一部分前端工程师对单测的认知是严重不足的，所以本节我们一起来聊聊前端的自动化测试。

首先我们先看看前端都存在哪些种类的测试。

测试分类
====

前端测试可以根据不同维度划分成很多种，下面是一些常见的前端测试分类。

按测试类型划分
-------

*   单元测试（Unit Tests）：

针对代码中的最小可测试单元进行测试，通常是函数、模块或基础组件。单元测试关注代码的内部逻辑和细节，确保每个单元都能按预期工作。

单元测试相对简单，但是意义重大，是保证代码质量的基础，这是我们前端自动化测试的一个重点。

*   集成测试（Integration Tests）：

在单元测试的基础上，将多个单元组合起来进行测试，验证它们之间的交互和协作是否正常。集成测试通常关注模块之间的接口和依赖关系。

集成测试相对较复杂，涉及多个模块、组件，测试用例相对更加复杂。

*   端到端测试（E2E Tests）：

端到端测试就是模拟用户在实际环境中的操作，对整个应用程序进行测试，以WEB测试为例，端到端测试需要在测试环境启动一个浏览器，然后就像用户一样打开页面，填充表单，模拟用户在真实环境的操作。端到端测试关注应用程序的整体功能和性能，确保应用程序能够正常运行并满足用户需求。

单元测试和端到端测试是前端自动化测试的重点。

按测试的覆盖范围划分
----------

*   功能测试

验证应用程序是否按照需求文档的要求进行功能实现，并检查是否存在遗漏、错误或不符合要求的功能，每次开发完新功能，前端进行的自测、同事之间的交叉测试以及提交给测试人员进行的测试，大都属于功能测试。

*   性能测试

前端性能测试主要关注网页或应用的前端部分在性能方面的表现，以确保用户能够在合理的时间内获得良好的体验。前端性能测试一般包含以下几个关键方面：

**页面加载时间（特别是首页）：**

首次显示时间（Time to First Byte, TTFB）：用户发出请求到浏览器开始接收响应之间的时间，主要反映网络延迟和服务器响应时间。

首次内容绘制时间（First Contentful Paint, FCP）：浏览器首次绘制任何文本、图片、非白色canvas或SVG的时间。

首次有意义绘制时间（First Meaningful Paint, FMP）：页面首次呈现出对用户有意义的内容的时间点。

DOMContentLoaded事件时间：当整个HTML文档被完全加载和解析完成之后，DOMContentLoaded事件被触发，无需等待样式表、图像和子框架的完成加载。

页面完全加载时间（Load Event Time）：页面及其依赖资源如样式表和图片都已完成加载的时间。

**响应时间：**

用户交互的响应时间，如点击按钮、滚动页面等操作时，页面作出响应所需的时间。

**资源加载：**

各个资源文件（如CSS、JS、图片等）的加载时间。

**网络性能：**

在不同网络环境下（如Wi-Fi、4G/5G、慢速网络等）测试页面的加载速度和性能。

**内存和CPU使用情况：**

测试页面在运行时对内存和CPU的占用情况，是否存在内存泄漏或CPU占用过高的问题。

前端性能测试主要还是通过一些监控库来完成。

*   兼容性测试

测试应用程序在不同浏览器、操作系统和设备上的兼容性，确保应用程序能够在各种环境下正常运行。

简单的兼容性测试可以通过人工手动测试，但是工作量巨大，而且周期也不会很频繁，也可以通过一些自动化测试框架来完成兼容性测试，比如selenium提供了多个不同版本的谷歌浏览器镜像，可以提前创建多个不同版本的浏览器镜像服务，然后可通过nightwatch等框架连接到不同版本浏览器进行兼容性测试。

*   安全性测试

测试应用程序的安全性，包括数据安全性、用户认证和授权、防止恶意攻击等方面，确保应用程序能够保护用户数据和系统安全。

*   回归测试

回归测试旨在确保在软件变更（如代码修改、新功能添加或配置更改）后，软件仍然具有其预期的功能和性能，并且没有引入新的错误或问题。换句话说，回归测试用于验证之前开发和测试过的软件功能在变更后是否仍然有效。

回归测试也是日常测试中的一个痛点，即使你只是新增或修改了项目中的一小块功能，在上线之前，仍然需要将其他未在本次需求变更范围之内的功能进行一次完整的功能测试，以确保没有引入新的bug，这个非常适合通过端到端测试来自动化完成。

按照测试的执行方式划分
-----------

*   静态测试（Static Testing）：

在不运行代码的情况下对代码进行分析和检查，之前在用友工作时，公司会定期对各个项目组的代码仓库进行扫描，然后把扫描结果发给各个团队进行处理，而百度则更先进一点，会在每次提交代码时，对代码进行扫描，不符合规范的代码是不能合入的。

*   动态测试（Dynamic Testing）：

动态测试方法是指通过运行被测程序，检查运行结果与预期结果的差异，并分析运行效率、正确性和健壮性等性能。它主要侧重于软件的实际运行过程，包括构造测试用例、执行程序、分析程序的输出结果等步骤。

按是否了解程序内部结构划分
-------------

*   白盒测试

白盒测试，也称为结构测试、透明盒测试或开放盒测试，测试人员可以查看并了解被测程序的内部逻辑结构、设计和实现方式。在这种测试方法中，测试人员根据对程序内部逻辑结构和相关信息的分析，设计或选择测试用例，对程序所有逻辑路径进行测试。

前面提到的单元测试就属于白盒测试，我们在写单测用例时，是了解程序的内部结构的，也会针对性的测试各种边界情况，也会尽可能让模块内的每个分支(if-else、switch-case)都走一遍。

*   黑盒测试

与白盒测试相反，黑盒测试是在测试人员在不了解被测程序内部结构和逻辑的情况下进行的，仅通过输入和输出来测试程序的功能。日常我们测试人员进行的测试都属于黑盒测试，前面提到的端到端测试也属于黑盒测试。

今天我们只讨论怎么通过自动化方式进行前端测试，主要讨论**单元测试**和**端到端测试**两种。

单元测试
====

前端到底要不要做单测
----------

要不要做一件事，我觉得主要还是看这件事的投入产出比，也就是产生的收益/价值是否大于投入的成本，以及当前是否有更高投入产出比的事情要做。

> 投入产出比 = 收益 / 成本

### 单测收益

那么写单测到底能给项目带来哪些收益呢？

1.  提高代码质量：

写单元测试的首要目的还是为了提高代码质量，减少线上事故。

单元测试能够尽早发现代码中的错误和设计缺陷，因为在写单测用例的时候，我们更多的是站在这个模块的使用者的角度去思考，而不是开发者的角度，这样更容易让我们发现逻辑上的缺陷，比如更加重视边界和异常情况。

每个小模块能够按照预期工作，也就减少了集成测试和系统测试时的故障，就像我们做好了自测工作，那么联调时肯定就省心省力不少，bug量肯定会降低。

单元测试可以反复、多次执行，减少线上出现问题的可能性，一般会在上线前执行一次单测，有条件的也会把单测集成到CI/CD中，每次commit提交都会触发执行一次单元测试，将问题拦截在上线前。

最后，写单侧还会倒逼我们写出更加具有可测试性的代码，减少模块之间的耦合。写测试用例时最麻烦的就是数据Mock，而一个模块和其他模块耦合越多，需要Mock的数据也就越多，而如果你必须要写单测，那么就会促使你去思考如何减少模块之间的耦合，从而被迫提高了我们的代码质量。

2.  促进重构和修改：

很多时候我们不敢进行重构，担心重构后引入新的bug，而如果有完善的单测作为后盾，你就可以放心大胆地进行重构了，只要重构后所有的测试用例都能执行通过，我们就可以认为此次重构没有引发新的问题，这就大大增加了我们重构的信心，可见单测对持续保证代码质量起到了很大作用。

3.  促进团队协作：

单元测试可以作为代码行为的规范和文档，如果你不知道一个功能怎么使用，只需要去看下它的测试用例即可，里面有非常详细的用法，可以说比文档更专业，这能够降低团队成员之间的沟通成本。

评估单测对项目带来的收益，除了看单测本身带来的价值，还要看项目服务的用户数量，以及如果发生线上事故对客户带来的危害程度。

> 单测带来的收益 = 项目质量收益 \* 用户数量 \* 危害程度

用户数量越大，影响范围越广，一旦出现问题带来的危害就越大，相应的单测价值就被放大，一个千万+级别用户的产品和一个个位数用户的产品对质量的要求肯定是不一样的。

不同的产品出现质量问题带来的危害程度也是不一样的，一个工业产品出现问题可能会导致工厂停产，甚至发生人身伤害事故，而一个品牌官网出现事故，则可能没有那么大的社会危害。功能出现问题造成的危害越大，则越应该做好代码质量，相应地应该增加单测。

### 单测成本

单测的成本主要看项目的功能复杂度和需求变更频率，功能越庞大、复杂，花费的单测编写时间就越长；而如果功能不稳定，经常发生较大的颠覆式重写，则会导致之前的单测失效，增加单测的成本。

我感觉这里其实存在一个悖论，越是功能复杂、越是变更频繁，成本越高，是不是越应该编写单测呢？前面我们说了编写单测能够让我们更加放心地重构，减少重构引发的质量问题。而如果一个项目很少发生变化，是不是单测带来的收益也相应地变低了。

总之，要不要做单测，还是要看项目对质量的要求，用户数越大，功能出现问题的危害越大，越应该做单测。实际工作中，很多时候不能完全由前端同学决定要不要做单测，更多地取决于领导对代码质量及对技术债的认知程度，但是我们不能因此否认单测存在的价值和意义，建议无论公司怎么要求，前端同学还是要尝试去做单测，做不做和会不会是有本质区别的。

哪些内容适合做单测
---------

当前前端开发模式下，需要进行单测的资源主要分为utils库和组件两大类，而如果对所有的组件进行测试，成本无疑是巨大的，比较有性价比的做法是对那些被多个模块依赖的功能进行单测，被依赖的越多，造成的影响越大，出问题引发的危害也就越大。

在我们前端项目中，被应用依赖最多的首先是第三方utils和第三方组件库，但是我们一般默认这些库是可信的，这些知名的库通常自身包含非常详尽的测试用例，而且我们也不会主动去修改这些库，所以对它们进行单测其实意义不大。

![sanceng.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f32b73338ca4a52bd38508b95bf3403~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=376&h=301&s=17101&e=png&b=fefefe)

其次，项目中被依赖最多的当属我们自己封装的基础utils和组件，他们数量不会非常大，变更也不会特别频繁，但是出问题影响的范围非常广，所以从性价比角度考虑，是最适合做单测的。

业务组件的变化非常频繁，每次需求的变更，都会导致原有的测试用例失效，都要重新编写。而且业务组件的测试非常地复杂，需要Mock大量的数据，比如全局状态Store、路由参数、网络请求等，导致单测的代码大小比源代码还要大很多，在实际工作中感觉对业务组件编写测试用例的意义不大，也很难坚持下去。

如何写好测试用例
--------

编写单测用例时，我们应该遵循四个原则：相互独立、完全穷尽、单一职责和可重复。

### 相互独立

相互独立就是每个测试用例都能对应不同的代码分支，每个用例起到的作用不一样，同样类型的测试用例写再多也没有意义。

比如我们对一个类似lodash.get方法进行测试，针对单个属性的获取用例写1个就够了，太多了也毫无意义。

    import {get} from './utils'
    
    describe('lodash get方法测试', () => {
        it('测试字符串类型的属性获取', () => {
            const object = { a: 1, b: 2, c: 3 };
            expect(get(object, 'a')).toBe(1);
            expect(get(object, 'b')).toBe(2); //重复，没有太大意义
            expect(get(object, 'c')).toBe(3); //重复，没有太大意义
        })
    })
    

单元测试是白盒测试，我们知道代码的内部结构，因此也有条件知道不同用例所执行的代码，可以做到每个用例的相互独立。

### 完全穷尽

用例要尽量覆盖所有的代码分支，除了覆盖正常场景，还应该关注各种边界和异常情况。

仍然以上面lodash.get方法为例，我们需要关注各种非正常的get场景，比如路径为空、路径不存在、路径中存在"."等各种边界情况。

    import {get} from './utils'
    
    describe('lodash get方法测试', () => {
        it('测试路径为空情况', () => {
            expect(get({a: 1}, '')).toBe(undefined);
            expect(get({'': 1}, '')).toBe(1);
        })
        it('测试路径不存在的情况', () => {
            expect(get({a: 1}, 'b')).toBe(undefined);
        })
    
        it('测试路径中存在.的情况', () => {
            const object = { 'a.b': 1, a: { b: 2 } };
    
            lodashStable.each(['a.b', ['a.b']], (path) => {
                
            });
            expect(get(object, 'a.b')).toBe(1);
            expect(get(object, ['a', 'b'])).toBe(2);
        });
        //省略其他各种场景的用例
    })
    

### 单一职责

测试用例和源码一样，也是要注意可读性的，而为了提升测试用例的可读性，最好的办法就一个测试用例只做一件事，不要把多个逻辑放在一个测试用例中。

在具体实施时，不同模块的测试用例应该分成多个文件；同一个模块的测试，可以分成不同的测试套件（一般用describe包裹）；每个测试套件可以包含多个相关的测试用例，每个小测试case一般放在名为"it"或"test"的函数中。

仍然以lodash为例，它的单测都放在test目录中，每个功能函数对应一个文件。

    └── test
        ├── clone-methods.spec.js
        ├── get.spec.js
        ├── forEach.spec.js
        └── ...
    

以get方法为例，我们可以将测试用例分成两大类：正常情况和异常情况，分别放到不同的describe中，每个describe又包含多个it，每个it只做一件事。

    describe('正常情况测试', () => {
        it('字符串类型属性测试', ()=>{})
        it('嵌套属性获取', ()=>{})
        it('数组类型属性测试', ()=>{})
        //其他
    })
    describe('异常情况测试', () => {
        it('路径不存在情况测试', ()=>{})
        it('对象不存在情况测试', ()=>{})
        it('测试路径中存在.的情况', ()=>{})
        //其他
    })
    

### 可重复

测试用例应能在相同的条件下多次重复执行，并且每次执行的结果都应该是相同的。

测试不能依赖外部环境，比如网络请求、全局状态、本地时间等，如果需要用到，则都应该进行mock，否则无法保证每次执行都能获取相同的结果。

    import {diff} from './utils'
    describe('测试时间diff', () => {
       
        it('测试时间差异', ()=>{
            expect(diff('2014-05-10', 'd')).toBe('1'); //diff依赖了系统时间，随着时间的推移，结果会变化
        })
    })
    

什么时间做单测
-------

我们经常会听到这样一个词："补单测"，一个"补"字就反映了大家开发单测的习惯，通常都是先写代码后写单测的，这其实并不是理想的做法。

在开发了一些开源库之后，我越来越体会到写单测的好处，也更加理解了为什么要提前写单测，这就涉及到一个软件开发方法论：测试驱动开发（Test-Driven Development，简称TDD）。

### TDD

TDD的核心思想是在编写实际功能代码之前，先编写测试代码，测试用例其实就是我们开发某个功能的目标，它描述了一个功能在某个输入下应该有怎样的结果，只要让一个又一个的测试用例通过测试，也就逐渐完成了我们的开发工作，就和我们做事前先定目标是一个思路。

下面是TDD开发的一个经典流程：

![09-tdd工作流程.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea7cc689e8444cee9c579a35d89251c2~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=854&h=738&s=48918&e=png&b=ffffff)

*   不可运行（测试失败）：写一个功能最小完备的单元测试，并使得该单元测试编译失败。
*   可运行（测试通过）：快速编写刚刚好使测试通过的代码，不需要考虑太多，甚至可以使用一些不合理的方法。
*   重构：消除刚刚编码过程引入的重复设计，优化设计结构
*   重复以上步骤

TDD的开发流程是一个持续迭代的过程，通过不断编写测试用例、实现代码和重构代码，逐步构建出高质量的软件系统。这种流程强调了测试的重要性，并将测试作为开发的驱动力，以确保代码的正确性和可靠性。

千万不要认为只要测试用例通过就行了，测试用例通过是最低标准，TDD的核心一环是重构，不断地优化代码结构并通过测试，通过这种方式帮助你编写出更高质量的代码。

### 用TDD开发lodash.get方法

接下来，我们以lodash.get方法的开发为例，看看TDD是如何工作的。

首先导出get方法，什么都不需要实现，只实现一个get方法的空壳。

//lodash.js

    function get(object, path, defaultValue){
        return;
    }
    
    
    module.exports = {
        get
    }
    

接下来开始编写第一条测试用例，期望调用get(obj, 'a')能够获取对象obj的a属性的值。

//get.test.js

    const get = require('./lodash').get;
    
    describe("get方法测试", () =>{
        it('对象测试', () =>{
            let obj = {
                a: 1
            }
            expect(get(obj, 'a')).toBe(1)
        })
    })
    

接下来执行这个测试用例，这里可以使用任意的测试库来执行这个测试用例，我一般习惯使用jest进行单元测试，使用什么库都无所谓，不影响TDD这种开发方式。

不出意外，这条测试用例执行失败了，因为我的get方法目前还没有任何实现，为了让这个测试用例通过，我只需要简单的修改get方法即可。

    function get(object, path, defaultValue){
        return object[path];
    }
    

再次执行测试用例，ok，通过了，至此围绕第一条测试用例的开发结束了，是不是特别简单，简直让人信心大增。

接下来继续添加测试用例，我们期望get方法不仅能获取对象的子属性，还能获取更深层次的属性，如get(obj, 'b.c')。

    const get = require('./lodash').get;
    
    describe("get方法测试", () =>{
        it('对象测试', () =>{
            let obj = {
                a: 1,
                b: {
                    c: 2
                }
            }
            expect(get(obj, 'a')).toBe(1);
            //新增一条测试用例
            expect(get(obj, 'b.c')).toBe(2)
        })
    })
    

执行测试用例，不出意外地又出错了，没关系，继续重构我们的get方法即可，检测path中是否包含字符'.'，如果包含则递归获取对象的值。

    function get(object, path, defaultValue){
        if(!path.includes('.')){
            return object[path];
        }
        let attrArr = path.split('.');
        let firstAttr = attrArr.shift();
        return get(object[firstAttr], attrArr.join('.'));
    }
    
    module.exports = {
        get
    }
    

虽然写的时候感觉上述实现可能不太完美，或者有潜在的bug，不过也不用太在意，后面我们再根据各种边界相关的测试用例补全实现即可，现在先把第二条测试用例通过再说。

再次执行测试用例，很好，又通过了，至此我们的实现已经成功支持2条测试用例了。

接下来我们可以继续添加测试用例--》执行测试得到失败反馈--》重构代码让测试通过，如此循环往复，最终实现一个满足了各种情形的get方法。

开发完之后，如果你觉得代码写的不够满意，可以重构你的代码，不用害怕重构中会带来bug，你可以修改个3-5行之后就执行一次测试用例，看看这次的修改是不是能让全部测试用例通过，通过则说明没有引入新问题，继续重构就行，如果有测试用例没通过则可以检查下原因，实在不行撤回这几行的变更换个思路修改就行。

是不是很棒，你不需要一开始就想出一个完美的实现方案，TDD的开发方式让你先动起来，然后通过重构优化代码，而不是上来就奔着一个完美的设计方案去开发，吭吭哧哧开发半天也不知道开发的对不对，有没有bug，TDD让你重拾对代码的掌控感！

这种方式尤其适合前端同学开发一些utils工具库，有机会一定要尝试下TDD。

单测中的一些概念
--------

### 断言（Assertion）

断言是测试用例中的关键部分，用于验证代码的实际行为是否符合预期，以函数的测试用例为例，断言就是设定函数在某些参数下的期望结果，如果返回值和期望结果一致，则断言通过，测试用例会继续执行，否则该条用例测试失败。

下面是测试框架jest中的常见断言语法：

    //jest下的断言
    expect(2 + 2).toBe(4);
    expect(2 + 2).toEqual(4);
    expect(2 + 2).toBeGreaterThan(3);
    expect(2 + 2).toBeGreaterThanOrEqual(3.5);
    expect(2 + 2).toBeLessThan(5);
    expect(2 + 2).toBeLessThanOrEqual(4.5);
    expect(1 + 1).not.toBe(0);
    expect(null).toBeNull();
    expect(null).toBeDefined();
    expect(1).toBeTruthy();
    expect(0).toBeFalsy();
    expect('Christoph').toMatch(/stop/);
    expect([ 'paper towels','milk']).toContain('milk');
    //...
    

### Mock

在单元测试中，经常需要通过Mock模拟代码中的外部依赖或复杂对象，以确保测试的独立性和可重复性。通过 Mock，我们可以控制被测试代码的环境，使得测试更加可控，同时可以避免测试受到外部因素的影响。

比如我们在Node环境下测试，就无法使用window对象，因为在node环境下没有window对象，因此必须进行Mock。

    // 在你的测试文件中模拟window对象  
    global.window = {  
      location: {  
        href: 'http://example.com',  
        protocol: 'http:',  
        hostname: 'example.com',  
        pathname: '/',
        // ...  
      }  
    };  
    
    function getHostName(){
        return window.location.hostname;
    }
    
    it('测试getHostName方法', ()=>{
        //如果没有模拟就会报错，node下不存在window对象
        expect(getHostName()).toBe('example.com');
    })
    

组件中的API请求也必须进行Mock，因为并不能保证每次API请求的结果都是一致的，如果不模拟则会导致测试结果不可靠。 除此之外一些运行时的数据也需要Mock，比如全局状态Store，因为我们只测试了一些基础组件，此时还没有进行Store的初始化，因此只能进行Mock。

### 覆盖率

在单元测试中，覆盖率（Code Coverage）是衡量测试用例覆盖代码的程度的指标，通常以百分比的形式表示。代码覆盖率可以帮助我们评估测试的完整性和质量，帮助发现代码中**未被测试到的部分**，从而帮助我们完善测试用例，一般测试框架在测试完成后都会输出一份测试报告，里面会有覆盖率相关数据。

常见的代码覆盖率指标包括：

*   语句覆盖率（Statement Coverage）：衡量测试用例是否覆盖了代码中的每一条语句，语句覆盖率 = 测试用例实际执行的语句数 / 代码中总的语句数。
    
*   分支覆盖率（Branch Coverage）：衡量测试用例是否覆盖了代码中的每个分支和决策点，分支就是if-else、switch-case，分支覆盖率 = 执行的分支数量 / 总分支数量。
    

如下是一个计算价格的用例，根据是否Vip进行打折，如果用例只测试了isVip=true的情况，那么这个函数的分支覆盖率只有50%，因为if-else中只有一条分支被执行了。

    function calcPrice(price, isVip){
        let result = price;
        if(isVip){
            result = price * 0.8;
        }else{
            result = price * 0.9;
        }
        return result;
    }
    
    it('测试calcPrice方法', ()=>{
        expect(calcPrice(10, true)).toBe(8); //该测试用例只执行了if分支
    })
    

*   函数覆盖率（Function Coverage）：衡量测试用例是否覆盖了代码中的每个函数，函数覆盖率 = 执行的函数数量 / 总函数数量，一个函数只要被调用一次就算被执行了。
    
*   行覆盖率（Line Coverage）：衡量测试用例是否覆盖了代码中的每一行，行覆盖率 = 执行的代码行数 / 代码中的总行数。
    

语句覆盖率和行覆盖率类似，但是略微有区别，比如下面这段代码，有5个语句，但是只有3行，如果每个语句都是一行的话，这两个指标是相同的。

    let a = 0; console.log(a);
    let b = 1; console.log(b);
    let c = 2;
    

测试覆盖率要不要定为100%呢？这个也是没有必要的，因为就算覆盖率达到100%也无法完全保证代码质量的，比如下面这个除法函数，很容易就达到100%覆盖率了，但是并没有考虑b为0的情况。

    function divide(a, b){
        return a / b;
    }
    

反而为了达到100%的覆盖率，写一些没什么意义的垃圾代码，导致重要的测试用例被忽视了，而且上有政策下有对策，很多时候就变成了为100%而100%，而不是充分去思考怎么设计合理的测试用例了。

但是测试覆盖率太低也说明测试并不充分，我们一般将覆盖率控制在80%以上，只有覆盖率低于80%，才需要补充用例。这里的基数也可能并不是项目中所有的代码，比如我们只要求基础utils和基础组件中的80%需要进行测试，而不是整个项目的80%的代码都需要经过测试，这个在框架中都可以进行配置。

E2E测试
=====

在本节最开始我们就提到了E2E测试（端到端测试），它是模拟用户在实际环境中的操作，对整个应用进行的自动化测试，在WEB产品的E2E测试中，通常会在测试环境启动一个浏览器（更多时候是无头浏览器），然后就像真实用户一样操作页面，以验证我们最终上线的产品是否符合预期。

为什么要进行E2E测试
-----------

前面我们提到了单元测试，它确实能帮助我们提升代码质量，但是却无法保证最终产出的产品是符合预期的。原因有两个：第一，前面我们说了，并不容易对所有组件进行单元测试，只针对一些基础utils和组件进行了单元测试；第二，就算所有组件通过了测试，也无法保证在真实环境中运行时不会出现bug，因为真实环境还涉及其他因素，包括浏览器类型和版本、网络环境、接口问题等。

E2E测试是最贴近用户真实使用场景的测试，通过了E2E测试才能真的认为产品质量通过测试。

在平时的测试中，我们一般把主要精力都放在了当次要上线的功能上，而对于哪些不在上线范围内的功能，很可能都不进行测试，这就可能导致上线后出现bug，而E2E测试是对回归测试的很好的补充。

在多权限账号的测试以及多个不同版本的浏览器兼容性测试中，E2E测试也可以发挥更大的作用，回想下我们平时上线前的测试，有多少人真的会把每个权限账号都验证一次，又有多少人会换不同的浏览器进行完整的功能验证，如果真的这样严格执行，人力成本无疑是巨大的。

E2E测试可以很好地解决上述问题，通过自动化的方式对功能进行回归验证，尽早发现线上问题。

谁来进行E2E测试
---------

如果对项目大部分页面进行完整的E2E测试，那么工作量还是非常大的，需要投入一定的人力资源，所以当然优先由专业的测试人员进行，而如果测试人员不具备编写自动化测试用例的能力或则测试资源不足，那么前端同学就是第一顺位继承人。

为什么前端同学要负责编写E2E测试用例呢？首先，E2E测试的主要还是前端的功能，属于前端的质量管理范畴；其次，E2E测试需要大量选择、操作Dom，前端同学更加熟悉这块技术；最后，基于javaScript的E2E测试框架非常丰富，比如Selenium、Nightwatch、Cypress、TestCafe等。

针对哪些功能进行E2E测试
-------------

E2E测试和单元测试有很大的不同。

单元测试提倡在写代码之前进行测试用例编写，而E2E测试则更期望在功能上线后且稳定一段时间后再编写测试用例，否则就造成大量的测试用例被废弃，而且新功能本身会有大量的人力资源投入到测试中，就算没有E2E测试也并不会有什么不好的影响。

单元测试会优先写那些重要的功能的，而E2E测试则可以优先写那些不常用到的、容易被人忽略的功能，因为我们的主要目的还是回归测试，重要功能一般都会在上线前点一点测一测，反而出问题的都是不那么重要的功能，所以E2E测试在不那么重要的功能测试上是个很好的补充。

单元测试推荐进行完整的测试，尽量包含各种边界和异常，而E2E测试则更倾向于核心的正常流程测试，优先保证主流程畅通。

前端配合E2E测试
---------

E2E测试的最大难点就是维护成本太高，在E2E测试中需要频繁定位Dom元素，比如我们要模拟登录按钮的点击，那么必然需要知道这个按钮的css选择器或者xPath，在前端没有特意配合的情况下，通常这个按钮的选择器会非常复杂，而且一旦前端的布局发生了变化，就会导致原有的选择器失效。

     it('登录', async function(){
            await browser
                .url('/login');
    
            await browser.element('#login-form > div.fm-btn > button').click();
        })
    

每次前端布局调整，都需要重写测试用例，这给用例维护带来了极大的工作量，慢慢地就放弃了维护工作，自动化测试往往沦为了一次性工作。为了减少这种情况，前端可以配合给一些特殊元素增加一些唯一性标志，比如id、自定义属性（如data-key、test-key）等，以减少前端布局变化导致的用例失效。

    <template>
        <!--为按钮、弹窗、表单元素等增加唯一标识-->
        <el-input test-key="username-form-item"/>
        <el-input test-key="password-form-item"/>
        <el-button test-key="login-button">登录</el-button>
    </template>
    

在用例编写时可以使用css的属性选择器精准选中Dom元素，这样无论UI布局怎么变，只要唯一标识不变，测试用例依然有效。

     it('登录', async function(){
            await browser
                .url('/login');
    
            await browser.element('button[test-key="login-button"]').click();
        })
    

E2E测试时机
-------

一般项目环境会分为这几种：开发环境、测试环境和正式环境，建议E2E测试针对测试环境进行。为什么这样说呢，首先，开发环境是不稳定的，针对其测试没有太大意义，而正式环境一般是不能随便动的，特别是我们要测试一些删除功能，在正式环境测试，可能会担心影响正式环境的安全，所以最好选择测试环境。

可以在每次将上线代码提交到测试环境后，且在QA同学测试之前，进行一次E2E测试，可以手动触发，也可以通过CI/CD的方式自动触发，这样尽量提早发现bug，并结合一些通知机制，及时将错误报告发给前端同学。

常见测试框架和库
========

单元测试和E2E测试都有很多优秀的前端框架和库，可以先任选其一进行学习，了解整个测试的工作流程，加深对自动化测试的认知，才是我们的首要目的，我一直认为框架和库的学习都是非常容易的，面向API编程而已，熟能生巧。

单元测试
----

### Jest

Jest是一个非常流行的 JavaScript 测试框架，它是Facebook开源的一款功能全面的JavaScript测试框架，尤其适用于React应用程序的测试，也可以结合@vue/cli-plugin-unit-jest进行Vue组件的单元测试。它提供了零配置的测试环境，支持快照测试、Mock等高级功能。Jest的优点包括开箱即用、API简单、支持断言和仿真、支持快照测试等。

知名库lodash就是使用jest进行单元测试的，我接触的第一个测试框架也是jest，确实非常简单。

### Karma

Karma是由Google团队开发的一套前端测试运行框架，它可以看作是一个JavaScript测试执行过程管理工具（Test Runner），Karma允许你在多个真实的浏览器中执行测试代码，它支持多种常见的浏览器Chrome、Firefox、Safari等，Karma的主要目的就是让你的测试驱动开发更加地简单、快速和有趣。

> The main purpose of Karma is to make your test-driven development easy, fast, and fun.

Karma会监控配置文件中所指定的每一个文件，每当文件发生改变，它都会向测试服务器发送信号，来通知所有的浏览器再次运行测试代码。浏览器会重新加载源文件，并执行测试代码，然后将结果传递回服务器，并以某种形式显示给开发者。

Karma通常需要与其他测试框架和断言库搭配，才能构建完整的测试环境。常见的搭配有Karma + Mocha + Chai、Karma + Jasmine等，知名库ElementUI就是使用Karma + Mocha + Chai的组合进行组件的单元测试。

### Mocha

Mocha是一个测试框架，它提供了灵活的测试环境，支持在Node.js和浏览器环境中进行测试。它最大特点就是允许你自由选择断言库，如Chai、Should.js、Expect.js等，以适应你的测试需求。 同样地，在进行Mock时，也需要与其他库（如 Sinon）结合使用，用于模拟函数调用、定时器等，方便编写复杂的测试用例。

所以相比Jest，它更加灵活，你可以自由组合断言库和Mock库，但是Jest入门要更加简单，里面已经封装好了一切。

### Chai

Chai是一个断言库，它只负责测试中的断言，所以在断言这一块，它更加专业，它提供了三种不同的断言风格供你选择。

*   expect：

这是Chai中最常用的断言风格。它使用expect(value)来启动一个断言链，并通过链式调用方法如.to.be.equal、.to.have.length等来进行断言。

     const chai = require('chai');
    const expect = chai.expect;
    
    describe('Chai Expect 断言风格', () => {
        it('字符串应该等于预期', () => {
            const str = 'Hello, Chai!';
            expect(str).to.equal('Hello, Chai!');
        });
    });
    

*   should：
    
*   在should风格中，你需要在对象上调用.should，然后链式调用断言方法。这种风格需要你在全局范围内启用should接口，或者使用require('chai/register-should')来在模块级别启用。
    

    const chai = require('chai');  
    chai.should(); // 启用全局should接口  
      
    describe('Chai Should 断言风格', () => {  
      it('字符串应该等于预期', () => {  
        const str = 'Hello, Chai!';  
        str.should.equal('Hello, Chai!');  
      });
    });
    

*   assert：
    
*   assert风格更接近于Node.js的内置assert模块，它提供了一组断言函数，如assert.equal(value1, value2)。在Chai中，你可以通过assert接口来使用这些函数。
    

    const chai = require('chai');  
    const assert = chai.assert;  
      
    describe('Chai Assert 断言风格', () => {  
      it('字符串应该等于预期', () => {  
        const str = 'Hello, Chai!';  
        assert.equal(str, 'Hello, Chai!');  
      });
    });
    

### Sinon

Sinon主要用于模拟对象、函数和服务器请求等行为。它提供了Spy、Stub和Mock等功能，帮助开发人员在单元测试和集成测试中隔离和模拟依赖项，以便更准确地验证代码的行为。

*   Spy（间谍）：

Sinon Spy允许你跟踪和验证函数的调用情况，例如它们被调用的次数、传递的参数以及调用的上下文等。Spy不会改变函数的行为，只是记录其使用情况。

比如当你对一个组件进行点击操作时，想要断言@click函数是否被执行了，参数是什么，就需要用到这个。

*   Stub（存根）：

Stub是一种测试替代品，它用于替代真实的函数或方法，以便在测试过程中模拟特定的行为或返回特定的结果。通过Stub，你可以控制函数的行为，以便在测试中隔离被测代码的依赖项。

比如你测试的方法依赖一个名为getUserName的函数，但是你不想真的执行这个函数，而是模拟它，比如你想强制让getUserName返回'admin'，这时你就可以通过Stub模拟一个只返回admin的getUserName函数。

*   Mock（模拟）：

Mock比Stub更加复杂，它不仅可以模拟函数的行为，还可以模拟整个对象或模块的行为。Mock允许你预设函数的返回值、抛出异常或模拟异步行为等。

比如有个获取用户详情的函数，里面会发送网络请求，但是我们在测试时并不希望真的发送请求，只是希望当用户id为1时返回某个数据，用户id为2时返回另外的数据，则可以通过这个技术进行模拟。

E2E测试
-----

E2E测试同样有很多知名的框架和库，如Cypress、Selenium、Nightwatch、TestCafe、Playwright、Puppeteer等，这里不再详细展开，感兴趣的同学可以自行查看，我在项目中主要使用Nightwatch + Selenium(构建不同版本的谷歌浏览器)进行E2E测试。

总结
==

前端测试具有多种不同的测试类型，其中单元测试和端到端测试是前端自动化测试中非常重要的两种。

建议对前端项目中的基础Utils和通用组件进行单元测试。

编写单测用例时，我们应该遵循四个原则：相互独立、完全穷尽、单一职责和可重复。

推荐在单测编写时采用TDD（测试驱动开发）的方式进行，先写测试用例，然后通过不断重构，逐渐完善代码实现，尤其是在基础Utils开发或者开源库开发时，TDD非常有效。

E2E测试是及时发现线上问题的重要手段，对回归测试有着非常大的帮助，建议对稳定的、非核心的功能优先进行E2E测试。

推荐大家在项目中先小范围尝试单元测试和E2E测试，体会、理解测试在前端的价值和难点，然后根据实际情况进行平衡。