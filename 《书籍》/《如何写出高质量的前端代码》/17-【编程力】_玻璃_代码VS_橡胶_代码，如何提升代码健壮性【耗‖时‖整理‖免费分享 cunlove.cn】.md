代码自从被部署到正式环境后，它就要面对各种各样的挑战，仿佛是在经历一场冒险，出人意料的用户操作、突然的网络阻塞、莫名其妙的脏数据、不知名的山寨浏览器...，面对各种各样的异常状况，你的代码还能否从容应对，依然坚挺呢？

不同人写出的代码"材质"是不同的，有的代码是"玻璃"做的，稍不留意就会掉在地上摔得粉碎，有的代码是"橡胶"做的，不管怎么蹂躏都能完好如初，仿佛是一个打不倒的"不倒翁"。

不同水平的开发者，虽然都能实现同样的一个业务功能，但是他们写出的代码健壮程度是差别巨大的，水平一般的开发者要求使用者必须严格按照某个流程或方式去操作，要求后端返回的数据必须是\*\*格式，要求浏览器必须是某某版本以上...，而且你会发现不同人写的代码bug出现概率是大大不同的，在我还是产品经理的时候，我就遇到过这样一个前端开发，一个小功能被我找出了一百个bug，简直令人发指！

本节我们就讨论下如何提升代码的健壮性，如何减少出bug的风险，以及如何降低出现bug后的影响范围，减少线上事故。

什么是代码健壮性
========

衡量代码稳定可靠程度时有一些指标，如健壮性、鲁棒性、稳健性等，定义虽然稍有差异，但内核大致是相同的。

在维基百科中关于稳健性和鲁棒性的定义如下：

> 计算机科学中，稳健性（英语：Robustness）是指一个计算机系统在执行过程中处理错误，以及算法在遭遇输入、运算等异常时维持正常运行的能力。

> 鲁棒性（英语：robustness），指事物可以抵御外部应力和影响并维持原有状态的自身性质。在生物学中，鲁棒性 (进化)，指系统在扰动或不确定的情况下仍能保持它们的特征行为。

总结起来，代码健壮性指的是代码在不同的环境和条件下或面对异常情况、不当输入时能够保持稳定性和可靠性的能力。健壮的代码能够有效地处理错误和异常，避免系统崩溃或产生不可预测的行为。

简单来说，在前端代码在面对异常情况时，仍然能够正常运行，不至于产生白屏、崩溃或数据错误等严重问题，或者即使无法为用户正常提供服务，但仍能给用户友好的提示信息，让用户知道发生了什么错误，并引导用户进行下一步操作。

为了提升健壮性，首要任务就是要找出前端代码运行时会有哪些可能的异常情况出现，而异常必然来自前端代码的运行依赖，所以接下来我们先梳理下前端代码都有哪些依赖，找出异常的来源，然后再寻找解决办法。

前端代码异常来源
========

一段前端代码在部署到服务器上之后，它的运行涉及到很多外部依赖，包括但不限于：用户的操作、API接口、权限、网络、缓存、浏览器、操作系统、服务器等，每个依赖的环境发生问题，都会导致前端产生异常。

![front_envs.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5140064957224101ac1506fd4de803c8~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=436&h=602&s=48592&e=png&b=ffffff)

*   用户操作：

用户往往都不会按照我们预想的去操作产品，这会导致大量的异常出现，比如输入了非法的字符、点击了不该点击的按钮，搞错了任务的先后顺序、进错了页面、各种非标骚操作等等，只有你想不到，没有用户做不到...

*   API接口：

接口并不总是按照约定返回数据，除去网络问题导致的异常，还有可能是返回了错误的数据格式、或者返回了空数据，这些都会导致前端代码运行时产生异常，更有甚者后端人员擅自修改了接口结构但并没有通知前端，如果前端没有妥善处理而导致了用户白屏，就只能和后端一起背锅了。

关于API接口的异常，有时也不完全是后端人员的锅，前端同学也存在责任，比如编辑时使用列表中的旧数据填充表单、传给接口一些不需要的数据、渲染下拉选项时拉取全量数据等。

*   权限：

权限问题是开发时容易忽略的一个点，一般为了方便都使用admin账号或其他高权限账号进行测试，而忽略了低权限用户访问的场景，导致用户看到了不该看到的数据、操作按钮，进入了没有权限的路由页面等。

*   网络：

用户的网络并不总是那么稳定顺畅，用户可能在地铁上、飞机上、火车上，可能是wifi、5G、4G甚至3G，你有没有试过在低速模式下访问你的网站或者App？在高速网络下正常的网站，并不一定能在低速下正常运行，高速网络有时候可能会掩盖一些问题，比如拉取全量数据低速下可能导致访问超时、低速下因为没有loading导致用户重复操作、低速还可能导致一些网络请求时序发生问题，比如先发起的请求后返回数据，导致一些意想不到的状况出现。

*   缓存：

前端经常被"群嘲"的一句话就是"你把缓存清下试试"，其实严格来说这也是一种bug，试想一个根本没有机会和研发交流的普通小白用户，哪里会知道要清除缓存？电脑都玩不明白呢。

*   浏览器：

你知道你的用户都在使用什么浏览器吗？你有多久没有用除了chrome以外的浏览器访问过你的网站了？感恩前端技术的发展，减少了对浏览器版本兼容的大部分工作，不过不同的浏览器还是存在一些差异的，可以降低兼容的工作投入，但是不能完全忽略不同浏览器带来的差异。

*   操作系统：

不同的操作系统也会造成一些差异，比如windows和macOS的字体渲染、滚动条样式等，尽可能使用不同操作系统访问你的网站。

*   服务器：

服务器的带宽、CPU、内存、磁盘等硬件资源，都可能成为前端代码加载/运行时的瓶颈，另外nginx的配置也对前端有很大的影响，比如缓存策略、gzip压缩、超时时间、body大小，try\_files等。

当然了，抛开这些前端代码运行的依赖环境，前端代码本身的逻辑严谨性，也对代码健壮性有很大的影响，如有没有考虑到各种边界情况，有没有注意时序问题，是否过于乐观地对待外部环境等。

如何提升代码健壮性
=========

知道了前端代码的异常来源，其实怎么解决已经呼之欲出了，接下来我为大家总结下我觉得行之有效的几种方法，不一定完全覆盖所有问题，但如果坚定地执行，相信一定会对代码健壮性有较大的提升，也让我们的代码质量再上一个台阶。

一、优化工作流程
--------

如果没有一套可执行的制度或者流程，而只是依靠每个前端同学的自觉性和编程能力，那代码健壮性将无法得到保证，可以说绝大部分的代码问题，都可以通过优化工作流程来避免，所以无论你是一位前端Leader还是普通大头兵，都应该推动团队优化前端开发流程。

### 设计文档评审

很多前端同学在接到需求之后喜欢直接进入开发阶段，而缺少设计文档编写，更别提设计评审了，仿佛只有进行代码编写才算自己在产生价值，才能让自己安心，其实这是非常不对的。

很多严重的问题都是"设计"出来的，当你进行编码时，很多Bug已经注定就要产生了，因为你的实现方案都存在缺陷，怎么能写出健壮的代码呢？方向不对，努力白费嘛。

而且当我们还是前端小白时，主要精力都集中在应对功能设计上，而对于各种边界问题、异常情况都考虑不足，这时候更需要借助团队的力量，帮我们提前排除风险，然而很多同学却没有认识到这件事的重要性，觉得设计是在给自己增加工作量，浪费时间，其实正因为你是前端新人，才更需要推动团队进行设计评审，于公可以写出更加健壮的代码，于私可以快速提升研发能力。

在前面的章节中我们已经详细介绍了如何编写前端设计文档，这里不再赘述，希望大家能够行动起来。

### Code Review

设计评审是保证代码质量的第一步，但设计文档和最终代码实现之间仍然可能会有很大的差异，只有对即将合入的代码进行严格的Code Review，才能发现哪些仅在特定条件下发生的异常。

Code Review对评审人员的水平有较高的要求，要能在很短的时间内看懂代码的实现思路并发现其中的问题，因此一般建议由团队中较资深成员承担。我认为前端Leader是Code Review的第一责任人，是其重要的一项团队工作，应该投入足够的时间来做好这件事。

和设计评审一样，Code Review也是新人学习和成长的绝佳时机，如果你们的团队还没有这个习惯，那么赶紧给你的领导提提建议吧。

### 严格的自测

有的同学可能会觉得，反正都有测试人员进行测试，那我为什么还要进行严格的自测呢？这种想法是错误的，每次提交给别人的产出，都代表着你的个人形象，影响着团队其他成员对你的评价，试想一下，如果一个后端总是把未经自测的接口发给你联调，你是什么感觉？如果你不喜欢这种感觉，那就不应该在未达到自己的"出厂标准"之前，就把代码提交给别人去测试。

所谓"严格"的自测，不说要有完善的测试用例，至少你应该对着需求文档，将所有的功能点都验证一遍，千万不要"艺高人胆大"，改了代码不去验证就转交他人，我们是自己代码的第一责任人，请爱惜自己的"羽毛"。

### 前端团队交叉测试

我建议在条件允许的情况下，前端团队应该进行交叉测试，别人开发的功能你帮忙验证下，等你开发的功能完成了也请别人帮你把把关，每次也就10-20分钟的时间，这样一方面可以在提测前将bug内部消化，另一方面可以增进团队成员对业务的了解，真正做到我为人人，人人为我。

### 自动化测试

为了防止一些基础或核心功能出现异常，必要的单元测试或者端到端测试也是一个很好的补充。单测属于白盒测试，可以更加针对性地对各种边界进行测试，而人工测试则比较难模拟各种边界情况，所以单测对健壮性也是非常重要的。

前面我们也已经详细的讲到了单测和端到端测试，同学们可以回顾下。

二、不要相信用户
--------

用户是非常不可控的因素，他们的性格、习惯、对互联网的熟悉程度、对产品的熟悉程度等等都差别巨大，我们既不能把所有用户都当"傻子"，也不能把所有用户都当聪明人，既不能把所有用户都想的那么善，也不能把所有用户都想的那么恶，总之不要相信他们，最好通过合理的规则来进行约束。

### 不要相信用户的输入

用户会有意或者无意地输入一些非法字符，轻则会导致程序报错，重则可能会带来安全风险。假设有个金币提现的功能，需要用户输入提现的金币数量，如果你仅仅要求输入值必须为Number格式，那么试想下会发生什么？对，用户可以输入负数，如果恰巧后端同学相信了前端的输入，每次用户进行提现操作时，都将当前金币数量减去提现数量后的值作为用户最终金币数量，那么就会发现用户的金币数量越来越多了...

在进行表单开发时，一般大家都会添加一些校验，这很好，不过也有很多同学会忽略一些细节，比如名称是必填字段，则可能只会配置如下一条规则，但是却忽略了其实名称也是有长度限制的，不能超过数据库中名称的存储最大长度，否则就会报错。

    let rules = {
       name: [
           {required: true}
       ]
    }
    

表单的校验大家经常会比较注意，而对于一些查询条件的输入则可能会忽略，比如如果你的后端采用的是mysql，当查询条件中输入"_"时，惊奇地发现也能查到数据，这是因为在SQL中，进行模糊查询通常使用LIKE操作符。LIKE操作符一般结合通配符使用，常用的通配符包括百分号%（代表任意数量的字符）和下划线_（代表单个字符）。

    # 如果我们想要查询名字以"John"结尾的员工：
    SELECT * FROM employees WHERE name LIKE '%John';
    
    # 如果我们想要查询名字恰好为三个字符的员工：
    SELECT * FROM employees WHERE name LIKE '___';
    

好了，在你的项目中试试输入如下样式的搜索关键词，看看会发生什么？这符合查询的预期吗？

    a%b%c  # 查询名字中包含a、b和c的记录
    a_b    # 查询名字中包含a和b，且a和b之间只有一个字符的记录
    ___    # 查询名字恰好为三个字符的记录
    .*     # 查询所有记录，适用mongoDB数据库
    \d     # 查询含有数字的记录，适用mongoDB数据库
    

总之，不要相信用户输入的任何数据，要做适当的格式校验或者转义，同样地，后端也不应该相信前端的输入，否则一旦用户选择绕过前端就会发生较大的风险。

### 防止用户进入无权限的页面

用户有时可能会突破你的限制，尝试访问没有权限的页面，虽然后端也会有权限限制，不一定会泄露什么数据，但是一旦后端的鉴权做的不到位，就会存在泄露数据的风险，你可以认为这属于代码安全性的范畴，但我认为这本质上是一种bug。

对于这种问题，简单的根据权限来控制用户的菜单是不够的，一旦用户直接在地址栏中输入无权限的页面地址就无法阻拦了，解决这个问题一般有两种做法可供参考。

**1\. 全量路由配置 + 拦截鉴权**

在路由注册时，注册全量的路由配置，但是在每次进入路由之前（router.beforeEach）都根据用户的权限进行校验，如果有权限则放行，否则进行拦截。

    const routes = [
        //全量的路由配置
    ]
    
    const router = new Router({
        routes,
        mode: 'history'
    });
    
    
    router.beforeEach(async (to, from, next) => {
        //检查用户是否有将要跳转的路由权限
        if (await checkPermission(to)) {
            next();
        } else {
            //无权限处理，可以跳转到403页面
            next('/403');
        }
    })
    

此方案是可行的，不过仍然有一些要需要考虑的边界问题：对某个路由权限的校验是前端进行还是后端进行？如果是后端进行那么必然每次都要发起网络请求，导致路由跳转耗时增加，但好处是用户的权限始终是最新的；如果路由鉴权由前端进行，那么用户鉴权信息你会存储在哪里？千万不要存储到localStorage或者sessionStorage中，会被用户修改掉，建议存储在内存中（如Store中）；如果前端存储了用户权限，那么后端更新了用户权限，前端怎么及时更新？如果采用定时刷新，岂不是有一段时间用户可以访问无权限的页面？所以如果这些问题不考虑清楚就会存在异常情况，这也是我们前面说到的，bug都是"设计"出来的。

个人建议采用如下两种方案：每次鉴权实时调用用户最新权限，以降低性能的方式换取安全性；前端进行权限校验，但是每次后台更新用户权限时，将用户登录token置为过期，这样后续用户会自动进入登录页面重新刷新整个前端的权限信息，以损失用户体验的方式换取安全性。

**2\. 动态路由**

前面路由配置中是全量的路由的信息，所以才需要每次都进行拦截，而如果我们在路由配置之初就只添加用户有权限的路由，那么不就不需要拦截了吗？在应用程序已经运行的时候添加或删除路由，这就是动态路由。

    const router = createRouter({
      history: createWebHistory(),
      routes: [{ path: '/login', component: Login }],
    })
    
    //获取用户权限
    //根据权限添加有权限的路由
    
    router.addRoute({ path: '/vip', component: Vip })
    

同样地，也是存在前后端权限如何及时更新的问题。

### 用户进入不存在的页面

前面我们提到了防止用户进入无权限的页面，还有一种场景是用户进入不存在的页面，这可能是以下几种原因：

*   **用户记错了网址**

这种情况需要让用户跳转到404页面，可以通过nginx配置或者路由配置进行设置。

    # nginx 配置
    
    server {  
        ...  
      
        error_page 404 /404.html;  
      
        location = /404.html {  
            root /path/to/your/web/root;  
            internal;  
        }  
      
        ...  
    }
    

    //路由配置404
    import Vue from 'vue'  
    import Router from 'vue-router'  
    import NotFound from '@/components/NotFound.vue' // 假设你的 NotFound 组件位于这个路径  
      
    Vue.use(Router)  
      
    export default new Router({  
      routes: [  
        // ... 其他路由定义 ...  
      
        // 通配符路由应放在最后，当匹配不到正确路由时进入404页面  
        {  
          path: '*',  
          component: NotFound  
        }  
      ]  
    })
    

*   **用户进入了以前的老地址**

有时我们会对前端项目进行重构并调整其中的路由配置，这时要注意一个问题，假如以前用户收藏了某些地址，那么在上线后如何处理，是不管不顾让用户进入404页面，还是进行一些适配，当发现用户进入的是老地址时，自动将其转向新路由。

    router.beforeEach(async (to, from, next) => {
        legacyRoute(to); // 兼容老路由，可以在2024年6月之后删除
        
        next();
    });
    
    function legacyRoute (to){
        if(/^/\d+/access/.test(to.fullPath)){
            //跳转到新路由
        }else if(/^/\d+/resource-pool/.test(to.fullPath)){
            //跳转到新路由
        }else if(/^/\d+/cluster/.test(to.fullPath)){
            //跳转到新路由
        }else if(/^/\d+/host/.test(to.fullPath)){
            //跳转到新路由
        }
    }
    

*   **资源被删除**

还有一种可能是用户之前收藏了一些资源的地址，但是资源被删除了，这时用户访问该地址可能无法请求到正确的数据。

如果将淘宝网地址栏中的商品id进行修改，淘宝的处理方式是提醒你宝贝不存在，如果将京东的商品id进行修改则会跳转到首页，这都是可以接受的，而如果将掘金的文章id进行修改则会无法访问，显然这里忽略了这种情况的处理，这也的确是我们经常忽略的一个情况。

![taobao.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8c1122ba374422190d4f82dd03d76a6~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=990&h=300&s=48250&e=png&b=fefefe)

![juejin.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a49081bf5664c8ea417ed8027798c8f~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=730&h=324&s=53738&e=png&b=202124) 好了，现在试着将你项目的路由id参数修改为一个不存在的值，看看你的网站是否正确处理了这种情况。

### 不应该的按钮点击

前端我们介绍了路由页面的一些异常情况，那当我们成功进入一个页面后，就需要考虑其中的操作按钮是否正确地被控制，这包括以下几种情况：

*   **点击无权限的按钮**

所有的操作按钮都应该进行权限控制，可以通过封装权限校验方法、指令或者高阶组件来完成，无权限可以是禁用操作按钮或者隐藏操作按钮，具体怎么做都可以，整个项目保持统一即可。

封装权限校验方法：

    <!--无权限禁用-->
    <button
        :disabled="!hasPermission('user.delete')"
    >
        删除
    </button>
    
    <!--无权限隐藏-->
    <button
        v-if="hasPermission('user.delete')"
    >
    删除
    </button>
    

封装指令：

    <!--无权限禁用-->
    <button
        v-permission.disabled="'user.delete'"
    >
        删除
    </button>
    
    <!--无权限隐藏-->
    <button
        v-permission.show="'user.delete'"
    >
    删除
    </button>
    

封装高阶组件:

    <!--无权限禁用-->
    <has-permission permission="user.delete" no-permission="disabled">
        <button>
            删除
        </button>
    </has-permission>
    <!--无权限隐藏-->
    <has-permission permission="user.delete" no-permission="hide">
        <button>
            删除
        </button>
    </has-permission>
    

*   **禁用不可点击的按钮**

如果一个按钮的点击取决于其他状态，我们就应该在某些条件下将其禁用，而不是允许其发送请求，然后返回错误。

    <button :disabled="status === 'running'">删除</button>
    

*   **防止重复点击**

重复点击可能会带来异常，比如连续两次进行保存操作可能会意外创建多条记录，可以在按钮点击之后就将其禁用，直到本次网络请求结束，或者我们对按钮组件进行二次封装，通过防抖或者节流，强制增大点击事件的响应间隔。

    <!--封装MyButton，避免连续点击-->
    <template>
        <el-button 
            :bind="$attrs" 
            :on="$listeners" 
            @click="clickHandler"
        >
            <slot></slot>
        </el-button>
    </template>
    <script>
    import {debounce} from 'lodash';
    export default {
        methods: {
            clickHandler: debounce(()=>{
                this.$emit('click')
            }, 500)
        }
    }
    </script>
    

三、不要相信后端
--------

在前端编程中，除了不能相信用户，还要对后端提供的API接口保持"悲观"，不能默认后台返回的数据一定是按照之前的约定进行的，有经验的前端都懂的~，后端总是会制作一些"惊喜"，本来应该返回对象结构的后端返回了null，本来应该返回数组结构的后端返回了空字符串，甚至后端私自调整了后端接口的返回结构然后偷偷上线，如果你毫无保留地信任他，就等着页面白屏吧。

之前大都通过lodash的get和set方法对后端返回的数据进行取值和设置操作。

    _.get(res, 'info.name'); //安全取值
    _.set(res, 'info.name', 'li'); //安全设置值 
    

这种操作实在太普遍了，所以ES6忍不住增加了可选链运算符（?.）

    const adventurer = {
      name: 'Alice',
      cat: {
        name: 'Dinah',
      },
    };
    
    const dogName = adventurer.dog?.name;
    console.log(dogName);
    // Expected output: undefined
    
    console.log(adventurer.someNonExistentMethod?.());
    // Expected output: undefined
    

除了取值和设置值，对值的所有方法调用都需要谨慎。

    //bad，认为后端返回的res中一定存在data且为数组
    res.data.forEach(()=>{});
    
    //good，但也有风险，res.data可能是对象
    ($_.get(res, 'data') || []).forEach(()=>{})
    
    // good 
    Array.isArray(res?.data) && res.data.forEach(()=>{})
    
    //bad，默认res一定有tags，且tags为字符串
    res.tags.split(','); 
    
    //good，但仍有风险，res.tags为数组则会报错
    (res?.tags || '').split(',');
    
    //good，确保调用split的为字符串
    (res?.tags + '').split(',')
    

可以看到，为了保证健壮性，代码的优雅性有一定的损失，但这仍是有必要的，或许我们可以考虑开发一些库来解决这个问题，在写下这些示例时，我突然有了一个灵感，能不能有一个库可以保证我们取的值一定是某种格式呢？比如我们可以扩展lodash，为其增加一些方法，既能安全取值又能保证数据格式。

    _.mixin({
        //增加一个方法，确保获取的值一定是数组
        promiseArray: function (obj, path){
            let value = _.get(obj, path);
            return Array.isArray(value) ? value : []
        },
        //确保获取的值一定为字符串
        promiseString:  function (obj, path){
            let value = _.get(obj, path);
            return typeof value === 'string' ? value : ''
        },
    })
    
    
    //可以安全遍历，promiseArray返回的一定为数组格式
    _.promiseArray(res, 'data.items').forEach(()=>{});
    
    //promiseString返回的一定为字符串格式
    _.promiseString(res, 'tags').split(',');
    

怎么样，是不是即安全又优雅，只要我们有了写出健壮代码的意识，就能想到各种解决办法。

好了，从现在起，不要再信任你们的后端，虽然你们可能是好朋友~~

四、不要使用旧数据
---------

在前端开发中我发现大家经常有这个习惯，就是每次在列表中点击编辑按钮打开弹窗时，经常会用列表中的数据填充弹窗表单，这可能会带来一些异常。试想下，如果两个人同时打开了列表页，并且别人已经对其中一条数据进行了修改，此时如果你在进行编辑时，使用列表中的旧数据填充表单，无疑会把别人的修改覆盖掉，这可能不是我们想看到的。

最简单的方法就是每次编辑时，始终通过网络请求获取当前最新数据，用这个最新数据填充表单。

不过这么做仍然存在问题，试想下，假如A和B两人同时打开了某个资源的编辑页面，虽然初始化数据时都是最新数据，但是A和B的保存操作肯定有先后，这就会造成后保存的覆盖先保存的情况发生，要解决这个问题有多种方法，但是都存在不小的成本。

*   方案1

资源增加一个最后编辑时间字段或者版本字段，当拉取资源详情填充表单时，存下来本次的版本号，在提交给后端时，后端校验下当前版本是否和数据库中最新版本一致，如果一致则允许修改，并将版本加1；如果提交的版本落后于数据库中的版本，则提示已经有人修改了当前资源，编辑失败。

*   方案2

当进行编辑操作时，创建websocket连接，查询下是否有人在编辑，如果有人在编辑则禁止编辑，当别人退出编辑时，后端通过websocket通知你可以编辑了，此时用最新数据填充表单并开始编辑操作，直到你退出编辑别人才可以重新获取编辑的权限。

*   方案3

通过websocket技术进行多人协作，不过这个成本就太大了，需要很繁琐的交互处理。

这些方案的实现都存在不小的成本，所以如果你编辑的内容不复杂且意外修改导致的后果并不严重，那么只需要确保每次编辑时采用最新数据即可，否则就要考虑被意外覆盖的问题了，比如你通过表单修改生成配方，如果被覆盖了则会导致后面工厂生成的产品出现问题，带来不小的经济损失，那解决这个问题就是必须要实现的功能了，而不仅仅是一个优化。

五、不要传递无用数据
----------

这种情况依然主要出现在编辑操作，当我们对一个资源进行编辑时，首先需要获取资源的详细信息，然后将数据填充给表单，然而并不是每个字段都需要进行编辑的，比如资源的创建时间、修改时间、创建人等等信息，如果传递一些用不到的字段，再加上后端处理不慎，就可能导致异常。

    let formData =  {};
    
    function initForm(){
        getUserDetail(uid).then(res=>{
            formData = res;  //res中包含很多额外数据
        })
    }
    
    function submit(){
        editUser(id, formData); //formData中包含不需要编辑的信息
    }
    

有时可能不是前端同学造成这个问题，比如明明只是要修改用户名称，可是后端接口让前端传递用户所有的信息，这种情况应该拒绝接受。

六、错误捕获
------

错误不可避免，不过我们可以通过一些捕获错误的手段，减少错误的影响范围，避免因为一个小问题而影响整个项目的运行。

### js 8大错误类型

首先我们快速认识下在js中有哪些错误类型，在ECMAScript规范中，有以下8中错误类型。

*   **RangeError**

RangeError 对象表示一个特定值不在所允许的范围或者集合中的错误。

在以下的情况中，可能会遇到这个问题：

a. 将不允许的字符串值传递给 String.prototype.normalize()

b. 尝试使用 Array 构造函数创建一个具有不合法的长度的字符串

c. 传递错误值到数值计算方法（Number.toExponential()、Number.toFixed() 或 Number.toPrecision()）。

    '\u0041\u006d\u00e9\u006c\u0069\u0065'.normalize('NFC');  //正常
    '\u0041\u006d\u00e9\u006c\u0069\u0065'.normalize('NFC2'); // Uncaught RangeError: The normalization form should be one of NFC, NFD, NFKC, NFKD.
    
    new Array(10); //正常
    new Array(1000000000000000000); //Uncaught RangeError: Invalid array length
    
    1.234.toFixed(2); //正常
    1.234.toFixed(200); //Uncaught RangeError: toFixed() digits argument must be between 0 and 100
    

*   **ReferenceError**

ReferenceError（引用错误）对象代表当一个不存在（或尚未初始化）的变量被引用时发生的错误。

    console.log(b); //Uncaught ReferenceError: b is not defined
    

*   **SyntaxError**

SyntaxError（语法错误）对象代表尝试解析不符合语法的代码的错误。当 Javascript 引擎解析代码时，遇到了不符合语法规范的标记（token）或标记顺序，则会抛出 SyntaxError。

    lett a; //Uncaught SyntaxError: Unexpected identifier 'a'
    

*   **TypeError**

TypeError（类型错误）对象通常（但并不只是）用来表示值的类型非预期类型时发生的错误。

以下情况会抛出 TypeError：

a. 传递给运算符的操作数或传递给函数的参数与预期的类型不兼容； b. 尝试修改无法更改的值； c. 尝试以不适当的方法使用一个值。

    'a'.map(); //Uncaught TypeError: "a".map is not a function
    const a = 1;
    a = 2; //Uncaught TypeError: Assignment to constant variable.
    

*   **URIError**

URIError 对象用来表示以一种错误的方式使用全局 URI 处理函数而产生的错误。

    decodeURI('%%'); //Uncaught URIError: URI malformed
    

*   **AggregateError**

AggregateError 对象代表了包装了多个错误对象的单个错误对象。当一个操作需要报告多个错误时，例如 Promise.any()，当传递给它的所有承诺都被拒绝时，就会抛出该错误。

*   **InternalError**

InternalError 对象表示出现在 JavaScript 引擎内部的错误。通常描述某种数量过多的情况，例如： "too many switch cases"（过多 case 子句）；"too many parentheses in regular expression"（正则表达式中括号过多）；"array initializer too large"（数组初始化器过大）；"too much recursion"（递归过深）。

*   **EvalError**

本对象代表了一个关于 eval() 全局函数的错误。此异常不再会被 JavaScript 抛出，但是 EvalError 对象仍然存在，以保持兼容性。

### 多使用try catch

我们知道，在js同步代码执行过程中，如果有一行出现异常，则后面的代码都将会停止执行。

比如下面这段代码，当进行危险的JSON.parse操作时，如果抛出了异常，则后面的初始化动作就停止执行了，这有事会对页面造成严重的后果，所以针对一些可能发生风险的操作，一定要加上try catch。

    function init(detailStr){
        console.log('开始init');
        let detail = JSON.parse(detailStr); //如果出现异常，后端的代码无法执行
        
        this.name = detail.name;
        this.age = detail.age;
        console.log('结束init');
    }
    init("{a:1")
    

对危险操作加上try catch后，即使出错整个初始化流程也会执行完成。

    function init(detailStr){
        console.log('开始init');
        try{
            let detail = JSON.parse(detailStr);
            this.name = detail.name;
            this.age = detail.age;
        }catch(e){
            this.name = '';
            this.age = 18;
        }finally{
            console.log('结束init');
        }
        
    }
    init("{a:1")
    

虽然道理很简单，但是很多时候大家都会遗漏try catch，比如凡是用到了 async await的地方，都应该通过try catch来捕获错误，除非你有意抛出错误；凡是对后端返回的数据进行JSON.parse操作或eval操作，都需要try catch，因为我们都无法预知结果，也无法提前对所执行的内容参数进行很好地校验，总之，凡是有风险的地方，加上try catch总没错。

### 监听错误发生

在可预知风险发生时，我们可以通过try catch来阻止错误的蔓延，不过仍然难免会有一些漏网之鱼，此时可以通过监听错误的发生来对错误进行统一的收集和处理。

*   **处理意料之外的全局运行时异常**

未被处理的JavaScript运行时错误发生时, 会触发window的error事件，可以统一监听处理。

    window.addEventListener('error', (e)=>{
        console.log('捕获到了错误', e);
    })
    
    const a = 1;
    a = 2; //故意制造error
    

*   **捕获Promise reject未处理情况**

不知道你有没有注意过这样的报错信息，当Promise没有配置.catch并且Promise的状态为rejected时，就会抛出如下错误。

![reject.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/762e4a5d9461429a80ce23fda020c4d0~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=344&h=57&s=4585&e=png&b=292929)

该错误信息可以通过unhandledrejection捕获到。

    window.addEventListener('unhandledrejection',(e)=>{
        console.log('捕获到了reject', e);
    })
    Promise.reject('dd')
    

不过虽然捕获到了，但控制台仍然有一条令人沮丧的报错信息，如果不想继续报错，可以通过e.preventDefault()来阻止。

    window.addEventListener('unhandledrejection',(e)=>{
        console.log('捕获到了reject', e);
        e.preventDefault();  //控制台不再有报错
    })
    Promise.reject('dd')
    

*   **捕获页面资源加载情况**

一般情况下如果我们不是写一些监控库，是无需考虑这个的，不过这里也给大家简单介绍下，扩展下思路。

当页面有一些静态资源加载失败时，比如一个图片404了，我们需要及时捕获这种错误以便我们快速响应，可通过PerformanceObserver获取资源加载情况。

    <script>
        new PerformanceObserver((entryList) => {
            entryList.getEntries().forEach((entry) => {
                console.log(entry)
                // 我们可以通过 entry.name 后缀或 entry.initiatorType 来判断资源类型
                // 可通过entry.responseStatus查看加载状态，如200、404
            })
        }).observe({ entryTypes: ['resource'] })
    </script>
    <!--加载一个不存在的资源-->
    <img src="img2.png"/> 
    

### 捕获Vue组件中的错误

Vue项目中任何一个组件发生错误都可以通过Vue.config.errorHandler来捕获，你可以自定义处理行为，或者将错误上报给监控系统。

    Vue.config.errorHandler = function (err, vm, info) {
      // handle error
      // `info` 是 Vue 特定的错误信息，比如错误所在的生命周期钩子
      // 只在 2.2.0+ 可用
    }
    

### React组件ErrorBoundary

ErrorBoundary 是 React 中的一个概念，用于捕获其子组件树中的任何未捕获的 JavaScript 错误，并打印这些错误到控制台，同时可以选择性地显示一个备用 UI 而不是崩溃的组件树。

如下，当组件AddCommentButton中有异常发生时，将会显示fallback中定义的内容，而不至于组件白屏。

    import { ErrorBoundary } from "react-error-boundary";
    
    export function AddCommentContainer() {
      return (
        <ErrorBoundary fallback={<p>⚠️Something went wrong</p>}>
          <AddCommentButton />
        </ErrorBoundary>
      );
    }
    

七、重视网络请求
--------

网络请求在前端的作用不言而喻，日常开发中大部分代码都是关于网络请求的，因此要特别重视网络请求相关的代码健壮性。

### 失败才是常态

网络请求成功只是意外，失败才是常态，就算你的服务器再好，后端接口再稳定，也挡不住用户网络异常等等原因，导致请求失败，因此要非常重视请求失败的处理。

别忘记在请求失败后依然进行数据初始化。

    function init(){
        getUserList().then(res =>{
            this.list = res.data || [];
        }).catch(_=>{
            this.list = [];  //不要忘记失败的初始化
        })
    }
    

有时大家喜欢使用async await 来改写异步的网络请求写法，那么一定记得要加try catch，否则处于异常后的代码将不会被执行，导致一些意想不到的状况发生。

    async function init(){
        let res = await getUserList();
        //如果请求抛出异常，后面代码不再执行，初始化动作未进行
        this.list = res.data || [];
    }
    

更好的写法：

    async function init(){
        try{
            let res = await getUserList();
            this.list = res.data || [];
        }catch (e){
            //多考虑失败了如何处理
            this.list = [];
        }
    }
    

### 关注慢速网络

网络速度较快时会掩盖一些问题，比如点击保存按钮进行数据存储时，网速快的情况下会迅速完成，感觉不到问题，而当网速较慢时，如果没有给予用户响应，比如添加一些loading，则会让用户感觉点击操作无响应，继而进行重复点击造成更不好的影响，所以只要是网络请求，就尽量添加loading，loading可以是全局loading也可以是局部loading，总之要让用户感觉到被响应了。

    function init(){
        this.loading = true; //开启loading
        getUserList().then(res =>{
            this.list = res.data || [];
        }).catch(_=>{
            this.list = []; 
        }).finally(_=>{
            this.loading = false; //无论成功或者失败，都别忘记关闭loading
        })
    }
    

在网速较好时，先发起的请求一般都会先获得结果，然而在网速慢时则不一定，比如A、B两个请求，A先发出，但是A的响应数据较大，B后发出但响应数据较少，很有可能B先结束，所以如果请求有先后顺序则一定要通过代码来控制，每次提测之前，用低速网络测试下你写的功能是个不错的习惯。

### 尽量不要请求全量数据

在进行表格展示时我们通常不会采用全量数据，然而在一些Select开发中，有些同学为了开发简单就会直接用全量数据渲染options，在测试环境数据较少时，通常没啥问题，然而等上线了就发现出现了接口响应严重缓慢的情况，甚至出现了超时失败，不管现在数据量有多大，当进行全量数据请求时一定要注意，建议采用根据用户输入关键词进行动态过滤的方式，每次只给用户加载一定数量的数据（比如最大50条）。

    <template>
        <el-select
            filterable
            remote
            placeholder="请输入名称查询"
            :remote-method="getUserOptions"
            :loading="loading"
            size="mini"
            value-key="id"
            @visible-change="$event && getUserOptions()"
        >
            <el-option v-for="item in userOptions"
                       :key="item.id"
                       :label="item.name"
                       :value="item.id"
                       
            ></el-option>
            <!-- 给用户一个提示，避免用户认为只有这么多数据 -->
            <el-option v-if="userOptions.length >= 50" disabled>
                <span>当前仅展示50条数据，可请输入关键词进行搜索</span>
            </el-option>
        </el-select>
    </template>
    <script>
    export default {
        data(){
            return {
                loading: false,
                userOptions: []
            }
        },
        methods:{
            getUserOptions(keywords){
                this.loading = true;
                getUserList({name: keywords}).then(res =>{
                    this.userOptions = res.data || [];
                }).catch(()=>{
                    this.userOptions = [];
                }).finally(()=>{
                    this.loading = false;
                })
            }
        }
        
    }
    </script>
    

### 别忘记取消网络请求

想象一下我们表格支持按照用户名称进行查询，并且是边输入边查询，用户先后输入了 'A'、'AB'，你这边也发起了两个查询请求，前面我们提到过前后两个请求到达的顺序并不总是和发送顺序一致的，如果到达顺序发生错乱，那么展示的数据和搜索关键词就不再一致了，bug也就产生了，所以在这种前后顺序对数据有影响的场景就应该取消之前的请求。

还有一种场景是在A页面发出了网络请求，但是在请求还未到达时，就切换到了B页面，那么在请求回调中的一些处理就会失败，因为A页面可能都已经销毁了，这种情况下也要注意，在卸载A页面时记得清除网络请求，或者做一些额外处理告诉请求页面已经销毁了。

八、别忘记清除定时器
----------

和取消网络请求一样，忘记清除定时器也会导致控制台产生一些错误警告，或者造成一些不可预知的风险，比如组件已经销毁，但是定时器未清除，那么定时器中对组件数据和DOM的操作可能就会产生问题，或者因为大量的定时器未清除导致内存溢出等问题。

九、增加监控
------

前面我们提到了很多主动防御代码异常的手段，不过无论我们自认为做的多么完善，难免都会有一些遗漏，那么怎么评价我们代码健壮性做的到底好不好呢，或者怎么评价我们的一些主动防御手段是否真的对代码健壮性起到了提升效果呢？要想评价必然要先有数据。

自从我们的项目中增加了监控，才发现原来有那么多异常啊，通过监控可以发现很多之前想都想不到的问题，不至于所有的bug都等着用户来告诉你，并不是所有的用户都是"社牛"，发现了bug会来告诉你，更多地用户则是默默地关闭页面选择离开，而有了监控，我们就可以主动出击，尽快解决项目中存在的问题。

如果你在大厂，一般公司都有完善的监控服务，只需要接入即可，而如果是一些中小厂，则可以选择自建、使用第三方库、或者付费服务来解决监控问题。

在前端错误监控方面，有很多优秀的第三方库可供选择：

1.  Sentry： 一款功能强大的开源错误监控平台，可以实时监控网站的错误，并提供详细的错误报告和堆栈跟踪信息。 支持多种编程语言和框架，方便开发者集成到现有项目中。 提供了丰富的统计数据和可视化界面，方便分析和定位问题。 提供了报警功能，当错误发生时及时通知相关人员。
    
2.  Bugsnag： 提供全面的错误监控和报告功能，能够捕获和分析网站的错误。 支持多种编程语言和平台，包括JavaScript、React Native等。 提供了详细的错误信息和堆栈跟踪，方便快速定位问题。
    
3.  TrackJS： 专注于JavaScript错误监控的工具，可以帮助追踪和分析前端代码中的错误。 提供了实时的错误报告和性能分析，帮助快速定位并解决问题。 支持自定义错误处理和过滤规则，方便根据项目需求进行定制。
    

总结
==

健壮性是衡量代码质量的一个重要指标，我们要写出像"橡胶"一样的代码而不是像"玻璃"一样的代码。

代码的异常来源有很多，用户的操作、API接口、权限、网络、缓存、浏览器、操作系统、服务器、自身代码的缺陷等，都会导致前端产生异常。

提升代码健壮性的方法：

*   优化工作流程：
    *   重视设计文档评审
    *   认真对待Code Review
    *   提测前进行严格的自测
    *   鼓励前端团队成员进行交叉测试
    *   核心功能进行自动化测试
*   不要相信用户：
    *   不要相信用户的输入，对表单、查询等用户输入一定要做校验
    *   防止用户进入无权限的页面，可通过全量路由配置 + 拦截鉴权 或 动态路由方式来实现
    *   如果用户进入了不存在的页面也要给予响应
    *   控制按钮的点击，包括控制操作权限、根据状态禁用按钮、防止重复点击
*   不要相信后端：注意安全取值，可以封装方法简化实现
*   不要使用旧数据，编辑操作应该拉取最新数据
*   不要传递无用数据，调用接口仅发送必要的最少数据
*   错误捕获：
    *   js 8种错误类型
    *   多使用try catch
    *   监听错误的发生进行合理的处理
    *   捕获Vue组件中的错误
    *   通过React组件ErrorBoundary进行异常处理
*   重视网络请求：
    *   网络请求失败才是常态，注意失败后的初始化处理
    *   关注慢速网络，提测前使用低速模式验证你的功能
    *   尽量不要请求全量数据，通过合理的交互避免全量数据
    *   别忘记取消会引起异常的网络请求
*   组件卸载前一定要卸载定时器
*   给你的项目增加监控，有了数据才能评价健壮性，才能主动解决项目中的异常

增加代码健壮性远不止上面提到的这些方法，这里仅仅是对业务开发中常见的一些方法做了总结，大家也可以多思考下还有哪些提升健壮性的方式。