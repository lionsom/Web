什么是组件
-----

组件（Component）是指一种可重用的UI+逻辑代码块，用于描述用户界面中的一个部分。组件可以包含HTML、CSS和JavaScript代码，可以被重复使用，可以根据需要进行组合和嵌套，从而构建复杂的用户界面。

> 组件 = UI + 逻辑

随着前端三大框架（React、Vue、Angular）的发展，如今Web页面的开发，已经完全变成了组件的开发，页面由一个一个的组件构成，组件就像是一个一个小的积木块，通过各种组合连接，最终搭建成一个庞大的项目。

![06-项目-页面-组件-子组件.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/777a219149d14d74b508e9dbc87e02ca~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=512&h=441&s=49879&e=png&b=fefefe)

组件化开发源于分治的思想，在面对复杂的任务时，分而治之是一种行之有效的解决问题方式，将庞大的复杂的系统，拆分成一个个单一的简单的可完成的小任务，然后逐个击破，随着小任务一个一个的完成，最终完成一个之前看起来很难或者不可能完成的大任务。

分治思想是一直存在的，所以组件化开发也并不是现在才有的，只是由于三大框架提供了非常优秀的组件开发范式，降低了组件开发的难度，让组件化开发得以普及。还记得几年前用Sea.js+jQuery开发前端组件时真的感觉很吃力，不仅封装组件很困难，使用组件也没有现在简单，虽然也能做，但是难度确实比现在大多了，而且组件的颗粒度也不容易做的太细。

感恩前端框架的发展，在现在的前端页面开发中，大到一个页面，小到一个icon，一切皆组件，可以说如果你不会封装组件，你就不是一个合格的前端工程师。

为什么要进行组件化开发
-----------

组件化开发能给我们带来很多收益，不仅体现在技术层面，而且对我们的工作流程都有很深的影响。

### 技术层面收益

1.  分离关注点，提升了代码的可读性

组件开发要求我们必须对页面结构进行抽象，看到一个页面就要思考这个页面应该拆分为几个模块，而不是在一段代码中平铺所有的细节，以一个官网页面为例。

没有进行组件化开发时，页面代码是这样的：

    <div>
        <div class="header">
            <img src="logo.png"/>
            <h1>网站名称</h1>
            <!--  其他头部代码    -->
        </div>
        <div class="main-content">
            <div class="banner">
                <ul>
                    <li><img src="banner1.png"></li>
                    <!--   省略n行代码      -->
                </ul>
            </div>
            <div class="about-us">
                <!--   省略n行代码      -->
            </div>
            <!--   省略n行代码      -->
        </div>
    </div>
    

你很难一眼说清楚这个页面到底包含几部分内容，如果"关于我们"部分有段内容要修改，你可能需要滚动鼠标滚轮来回查找，你必须阅读大量和"关于我们"无关的代码，才有可能定位到你要修改的内容在哪，很容易迷失在细节的海洋里。

通过组件化开发重构后：

    <div>
        <Header/>
        <main>
            <Banner/>
            <AboutUs/>
            <Services/>
            <ContactUs/>
        </main>
        <Footer/>
    </div>
    

可以看出，页面结构非常清晰，想要修改"关于我们"的内容，直接进入AboutUs组件即可，不需要再去关注那些和本次目标无关的内容，让你的关注点局限在特定的组件内部，增删改查某个模块都变得异常简单，代码可读性大大增强，维护难度大大降低。

2.  提升复用性

组件抽取的一个重要目的就是为了消除重复，消除重复带来两个重大收益：提升开发效率、降低维护成本。提升开发效率很好理解，不需要重复造轮子了，拿来就用；降低维护成本主要是当需求变更时，只需修改组件一处即可，不需要四处修改。

3.  UI更一致

在多个前端同学进行协作时，如果没有一套公共组件，每个人做出来的页面风格可能差别很大，就算有UI规范，也不能保证每个人都能严格遵守，比如一个简单的标题，可能每个人设置的字体大小、颜色、padding、margin都不能保证完全一致，通过组件化，可以将规范通过组件进行实现，开发人员只需要使用组件即可，不用记忆繁琐的规范。

    <!-- 不同级别的表单标题 -->
    <FormTitle :level="1"/>
    <FormTitle :level="2"/>
    

组件化是推动UI规范的重要载体，繁琐的规范是没有人能够记住的，也没有必要去记住那么多细节。

4.  提升可测试性

每个组件都有自己的职责和功能，可以被清晰地定义和实现，从而可以容易地进行测试，相较于复杂的大页面，组件的测试相对更加简单纯粹。

### 工作流程层面收益

组件化开发不只对Code有帮助，对工作流程也有很大的影响。

1.  方便多人协作

曾经做过一个低代码大屏编辑器，当时由7个前端同学共同开发完成，在开发之前，我先将低代码编辑器功能拆分为多个子组件，包括工具栏、物料选择、绘制区域、属性编辑等，接着制订好各组件之间的通信方式及需要共享的数据，最后小组每个成员分别负责一个组件的开发，最终在很短的时间内完成了一个技术含量相对较高的项目开发。

如果没有组件化这种开发方式，就算给我再多的人，我也没法合理的安排他们的工作，也没法集中团队力量办大事。

     <!--一个低代码编辑器拆分成多个子组件-->
     <!--子组件还可以继续进行拆分-->
    <template>
        <div>
            <!--顶部工具栏-->
            <ToolBar/>
            <main>
                <!--物料选择-->
                <MaterialSelect />
                <!--绘图区域-->
                <DrawingArea/>
                <!--属性编辑-->
                <PropertyEditing/>
            </main>
        </div>
    </template>
    

2.  前端人才结构分层

每个前端团队都应该努力构建自己的组件库，组件库不只是提高了团队研发效率，更重要的是它降低了前端开发门槛，对团队成员的要求降低了。

没有组件库时，要想获得较好的开发质量，每个人必须能独当一面，每个人都要有较高的研发水平，这就意味着团队研发成本上升。如果团队成员技术水平参差不齐，那么很容易发生代码质量参差不齐的情况，组件库能很好地解决这个问题，有了一个高质量的团队组件库，哪怕是一个实习生进来，也能很快进行高质量的产出。

组件库让整个团队的结构发生了变化，可以由1-2个老手带领几个新手来完成研发工作，而不必每个人都具有很高的技术水平。

组件化开发深刻影响了前端团队的人员结构。

何时进行组件抽取
--------

组件化开发很好，那何时需要抽取组件呢，我觉得可以从以下4个角度来考虑：

*   复用性

如果一个功能在多个页面都有使用，或者可以预期在后续会被重复使用，那么就可以把它抽取为组件。

更多的时候，刚开始没有意识到或者没必要将一个功能抽取为组件，但在后续的需求开发当中，发现需要复用这个功能，那么请先花点时间将它抽取成一个组件，然后再进行新代码的编写，这也是比较推崇的一个工作方式，先重构旧代码再开发新需求。

*   复杂度

如果一个组件的复杂度较高，那么它可能需要被拆分成多个小的、可重用的组件，以便更好地管理和维护，根据个人多年的开发经验，单个文件代码行数最好不超过300行，行数太多会给代码的可读性带来严重的障碍，我相信没有一个人喜欢阅读动辄成千上万行的单文件代码，那我们有什么理由去写这样的代码呢？如果你发现一个文件代码行数超过300行甚至达到了千行以上，那么是时候进行组件拆分了。

*   结构化编程

就像前面我们说到的一个品牌官网的开发，并不一定是因为页面代码行数太多去拆它，也不是为了复用去拆分它，而是单纯地不想在一个页面中展示太多细节。我们想要看清楚功能的主结构，所以将一个官网页面分成banner轮播、产品服务、关于我们、联系我们等几个大模块，然后再分别去实现这几个子组件。

这就像我们平时演示PPT一样，先告诉大家今天我要讲哪几部分内容，然后再展开说说各部分的细节，而不是一上来就说一大堆细节，让人不知道你究竟想要表达什么。

*   分离关注点

一个组件应该有它的重点任务，在别人阅读你的组件实现时，不应该用一些非主线的代码把他的关注点吸引走。

比如我在进行一个添加用户组件的开发，其中有个表单项是用户所在地区（级联选择省市区），如果我不把用户所在地区抽成一个组件单独开发，那么我这个添加用户组件内大部分代码可能都是关于如何实现地区级联选择的，但这是我这个添加用户组件的核心吗？

作为一个添加用户组件，主要关心的应该是如何初始化表单数据、配置表单校验规则以及提交表单数据这样的事情，而不是去关心其中一个表单项怎么去实现，如果在这个页面中混杂太多的表单项的实现，就扰乱了阅读者的关注点，给代码阅读增加障碍，影响可读性。

如何写出好组件
-------

如何评价一个组件的好坏呢？我觉的可以站在组件使用者和维护者两种角色的角度去考虑。

对于使用者来说，一个好的组件应该具备**通用性强**和**易用性好**这两个核心特性。

通用性强，意味着组件能在很多场景中发挥作用，可以在项目中大量使用，也就是复用性要好；而且就算面对一些特殊场景，也可以通过简单的扩展来满足特殊需求，即可扩展性要好。

> 通用性 = 复用性 + 扩展性

易用性好，意味着使用起来非常简单，即使不进行配置，或者只需要进行简单的配置就能让组件满足大部分使用场景，哪怕是一个新手，都能很快掌握组件的使用方法。

对于组件的维护者来说， 一个好的组件应该具备较好的**可读性**与**正交性**。

可读性好，意味着组件内部结构清晰，特别是内部的数据流转要清晰可见。

正交性好（低耦合），意味着组件的耦合少，组件的实现尽量不要和外部（父组件、数据仓库、url参数等）产生太多耦合，也不要和子组件过度耦合。

> 好组件评价指标 = 复用性 + 扩展性 + 易用性 + 可读性 + 正交性

如何提升组件的这几个指标，有一些具体的方法，下面我一起来学习下。

### 提升复用性

提升组件复用性有两个重要的方法：第一个是对业务进行抽象，找出多个业务模块的共性；第二个是组件开发要遵循单一职责原则。

*   **用抽象代替具体**

在开发某个功能页面时，不能只是针对当前要开发的功能需求进行组件抽取，而是要跳出来，从整个系统的角度去考虑，有没有相似的使用场景，然后站在更高的维度去抽取组件，学会使用抽象思维，而不是针对具体业务具体场景去设计组件。

记住，越抽象复用性就越强，越具体复用性就越差。

我们来举个例子，假设在用户列表的上面有个搜索区域，可以通过输入姓名和手机号进行搜索，如下图：

![06-搜索组件示例.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6edef6f0f8942d891742d7e65d8d6ca~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=614&h=110&s=13260&e=png&b=fefefe)

现在我们想把搜索这块封装成一个组件，如果只针对这个场景去封装，我们把这个组件命名为UserSearch，最终组件大致是这样的（以vue2组件开发为例，简化了实现）。

    <template>
        <div>
            <input v-model="name" placeholder="输入姓名筛选"/>
            <input v-model="phone" placeholder="输入手机号筛选"/>
            <button @click="emitSearch">搜索</button>
        </div>
    </template>
    <script>
    export default {
        name: 'UserSearch',
        data(){
            return {
                name: '',
                phone: ''
            }
        },
        methods:{
            emitSearch(){
                this.$emit('search', {
                    name: this.name, 
                    phone: this.phone
                })
            }
        }
    }
    </script>
    

由于UserSearch这个组件是针对这个具体业务场景抽取的，没有经过抽象，所以只能用在用户列表搜索这个特定的场景，复用性很差。如果你后续开发产品列表，你可能又要创建一个名为ProductSearch的组件，每次都要重新开发。

而如果我们站在项目的角度去考虑呢？搜索是我们各个列表页都需要的功能，观察不同列表的搜索功能，我们会发现他们有一些共同特点：右侧都有个搜索按钮，左侧是一块表单区域但是表单内容不固定，点击搜索按钮时会通知列表根据表单输入内容进行数据查询。基于此我们可以抽象出一个通用的搜索组件SearchForm，由于表单内容不固定，我们可以对外暴露一个属性，如fields，用来配置左侧有哪些表单项，包括每个表单的名称、类型以及属性，在点击搜索按钮后对外抛出search事件，这样几乎每个页面都可以复用这个组件，只要配置不同的fields即可。

    <template>
        <SearchForm
            :fields="fields"
            @search="search"
        />
    </template>
    <script>
    export default {
        data(){
            return {
                fields:[
                    {
                        key: 'name',
                        label:'姓名',
                        component: 'input',
                        props:{
                            placeholder: '输入姓名筛选'
                        }
                    },
                    {
                        key: 'phone',
                        label:'手机',
                        component: 'input',
                        props:{
                            placeholder: '输入手机号筛选'
                        }
                    }
                ]
            }
        },
        methods:{
            search(data){
                //刷新表格
            }
        }
    }
    </script>
    

这个SearchForm怎么实现大家可以先自行思考，后面实战环节会详细介绍如何实现该组件。怎么实现其实并不是最关键的，大多时候只要一个组件需求明确，我们都可以实现它，而关键是，当没有人给你提出技术需求时，你能不能通过抽象思维自行提炼出这样的公共组件设计。

抽象能力是我们编程时要具备的一项核心能力，在开发组件时，可以多去试着站在系统的角度看问题，进行更高维度的抽象。

*   **单一职责**

组件就像积木，通过各种组合，组成更大的功能模块或页面，越是功能单一的积木用途就越广，越是复杂的多功能积木用途就越窄，组件也是一样的道理。就像ElementUI中的那些组件一样，每个组件功能都很单一，比如icon、button、input等，越是这种功能很小很单一的组件，越是能通过组合发挥出更大的威力，适用于各种功能、各种页面、各种行业。

![06-组件单一职责增强复用性.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/240d787d1338478587fdd70f217613a4~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=622&h=527&s=77123&e=png&b=fefefe)

所以在封装组件时，尽可能满足单一职责原则，特别是一些通用组件和项目基础组件，更是要遵循这个原则，对于业务领域组件来说，虽然功能相对复杂一些，但是也尽量一个组件只完成一件业务功能，这样能大大提升组件的复用性。

### 扩展性

通过抽象，虽然可以应对绝大部分场景，但是难免会有一些特殊需求，这时就要靠组件的扩展性来满足用户需要了。组件本身由DOM、逻辑和样式组成，所以要提升组件扩展性我们也需要从三个方面去考虑，即如何扩展DOM，如何扩展逻辑以及如何扩展样式，解决了这三个问题基本就解决了组件的扩展性。

> 扩展组件 = 扩展DOM + 扩展逻辑 + 扩展样式

*   **扩展DOM**

插槽是提升组件DOM扩展性的一个重要方法，通过插槽我们可以扩展组件的DOM结构，而不必去修改组件本身，这也符合软件开发的开闭原则，即对扩展开放，对修改关闭。

在ElementUI组件中大部分组件都提供了插槽，比如input组件就提供了4个插槽。

![06-input插槽.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3233e29d8224aa28036609266915fda~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=664&h=281&s=19077&e=png&b=ffffff)

虽然插槽很简单，但是实际开发中很多人未必想到去用，比如现在有一个表单中的标题组件FormTitle，如下图所示，每个标题前面有个绿色的竖线。

![05-表单标题1.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5cf6c1febf6464a890dac6d72bdb998~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=493&h=166&s=11499&e=png&b=fefefe)

大部分情况表单标题都是上面这种样式的，但是在添加用户的表单标题上有个提示图标或者按钮，如下图这样。

![05-表单标题2.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64c17ec589be435b864cd1611732035a~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=407&h=146&s=17558&e=png&b=fefefe)

这时候，就会有一些同学这样做：既然是添加用户的表单出现这种情况，那我给组件加一个属性，告诉组件当前是在添加用户页面，组件内部根据这个属性来修改DOM。

这样做虽然解决了这个问题，但是却非常不合理，因为我们这个组件叫FormTitle，而不是UserFormTitle，显然它是一个非常通用的组件，通用组件不应该耦合业务逻辑，所以最好的方式还是提供一个插槽，业务模块有特殊需求时就使用插槽去扩展。

值得一提的是，在使用插槽时，记得给插槽一个合适的默认值，而不是每个使用组件的地方都必须要配置插槽，注意组件的易用性。

*   **扩展逻辑：钩子函数**

插槽给予我们扩展UI的机会，而如果想要扩展逻辑，则需要提供一些钩子函数。

假如我们开发这样一个CommonTable组件，希望它能够自动请求数据，然后以表格形式渲染出来，为了实现这个功能我们可能这么设计，传递给CommonTable组件一个API地址。

    <CommonTable api="/api/v1/user"/>
    

很明显这里的API要遵循同一套规范，比如能够支持按照pageNumber和pageSize的筛选，返回数据也必须按照固定的格式，如果所有的API都是企业内部的还好，一旦涉及外部API接口，这个组件可能就不适用了，人家返回的数据格式和规范肯定不相符。

我们可以这样进行扩展，为组件增加一个parseData钩子函数，每次请求API数据之后，调用parseData进行数据转换，这样就能将不符合规范的第三方接口返回值修改为满足组件要求的格式。

    <template>
        <CommonTable api="/other-api/user" :parseData="parseData" />
    </template>
    <script>
    export default {
        methods:{
            parseData(data){
                //对数据格式进行处理
                return data;
            }
        }
    }
    </script>
    

上面这个扩展方式还有局限性，如果第三方接口不支持表格传递过来的pageNumber和pageSize参数，那么请求到的数据就不正确了，为此我们可以让api属性支持两种格式：字符串和函数，如果是字符串，则认为是个接口地址，如果是函数则直接调用这个函数进行数据请求。

    <template>
        <CommonTable :api="getData" />
    </template>
    <script>
    export default {
        methods:{
            getData(pageNumber, pageSize){
                return request('/other/user',{
                    params:{
                        num: pageNumber,
                        size: pageSize
                    }
                }).then(data=>{
                    //数据处理
                    return data
                })
            }
        }
    }
    </script>
    

这样无论什么样的接口，组件都可以灵活应对了，通过钩子函数的方式让我们能够扩展组件的内部逻辑，而不需要修改组件的原有代码。

*   **扩展样式：自定义样式**

除了扩展DOM、逻辑之外，组件通常还需要支持扩展样式，要能够给用户修改样式的机会，比如能够接收用户传递过来的style或class。

以ElementUI的Popover组件为例，可通过popover-class属性设置弹窗内容的类名。

![06-popover自定义样式.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d47cce1f23a44b6ba54144ade3d7ace~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=411&h=86&s=5516&e=png&b=ffffff)

另外还需要注意一点，在组件内部尽量不要通过 !important去设置样式，特别是一些基础组件，要留给用户修改样式的机会，建议通过CSS优先级去设置样式。

### 易用性

通用性解决了能不用的问题，而易用性解决了好不好用的问题，特别是对一些新手来说，易用性则是他们更加关注的。

*   **傻瓜式使用**

我之前做过一个开源项目： [vue-office](https://github.com/501351981/vue-office "https://github.com/501351981/vue-office") ，用来解决docx、xlsx、pdf文件的预览，之所以开发这个组件，就是因为我看到同事为了实现文件的预览要写大量的代码，而我认为预览一个文件应该极其简单，只要传递文件地址即可实现文件预览，为此我开发了这样一个组件库，刚上线几个月即收获了1K+ star，虽然我并没有实现多么高深的底层预览库，只是站在巨人的肩膀上进行了一层简单封装，但是由于大大简化了使用方式，提供了一整套预览方案，大大增强了易用性，对新手来说更加友好，由此也获得了大家的认可。

    <!--使用vue-office进行docx预览-->
    <template>
      <vue-office-docx src="**.docx"/>
    </template>
    

*   **减少配置，默认值满足大部分需求**

为了应对各种场景，组件可能会有很多属性，但即使不配置任何属性，或者仅需配置1-2个属性，组件就应该能满足80%以上的使用场景，这就要求在开发组件时，分析各种场景出现的频率，为每个属性设置合理的默认值。

*   **符合用户习惯**

组件的属性、事件和插槽名应该符合用户的使用习惯，尽量不增加用户的心智负担。

比如我们要开发一个新增用户弹窗组件，作为弹窗应该有个属性来控制弹窗的显隐，那么这个属性叫什么呢？hide、show、open还是visible？如果你们的项目都在使用ElementUI组件库，那么显然visible是最佳选择，因为在ElementUI中dialog的显隐就是通过属性visible控制的，所以当用户看到dialog弹窗，就自然而然地想到用visible属性来控制弹窗显隐，没有任何记忆负担，相反，如果你在属性/方法命名时比较随意，别人为了使用你的组件，还必须要记住每个组件的属性，那太痛苦了。

组件的每个属性命名都值得反复斟酌，尽量给人一种"就应该那样"或者"和我想的一样"的自然而然的感觉，所以高手在用其他高手写的组件时，往往不用看手册就能猜出来怎么使用，而新手总是那么让人"意想不到"。

> 如何提升组件的可读性和正交性，以及组件开发应该遵循怎样的流程，我们放到下节再说。