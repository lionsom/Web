# 一、JS异步操作的实现

JavaScript 中实现异步操作有多种方式，以下是常见的几种方法：

## 1. 回调函数

通过将一个函数作为参数传递给异步操作，当异步操作完成时调用这个函数，这个函数就是回调函数。回调函数是最早也是最常见的异步编程模式，例如：

```js
function fetchData(callback) {
    // 模拟异步操作
    setTimeout(() => {
        const data = '异步数据';
        callback(data);
    }, 1000);
}

fetchData((data) => {
    console.log(data);
});
```



## 2. Promise

Promise 是一种用于处理异步操作的对象，通过 Promise 可以更加清晰地处理异步操作成功、失败和异常的情况。例如：

```js
function fetchData() {
    return new Promise((resolve, reject) => {
        // 模拟异步操作
        setTimeout(() => {
            const data = '异步数据';
            resolve(data);
        }, 1000);
    });
}

fetchData()
    .then((data) => {
        console.log(data);
    })
    .catch((error) => {
        console.error(error);
    });
```



## 3. async/await：

async/await 是基于 Promise 的异步编程语法糖，可以使异步代码看起来像同步代码。使用 async/await 可以在函数前加上 async 关键字，使其成为一个异步函数，并且在异步操作前使用 await 关键字等待异步操作的结果。例如：

```js
async function fetchData() {
    return new Promise((resolve, reject) => {
        // 模拟异步操作
        setTimeout(() => {
            const data = '异步数据';
            resolve(data);
        }, 1000);
    });
}

async function handleData() {
    const data = await fetchData();
    console.log(data);
}

handleData();
```





# 二、概念补充

## 1. 并发与并行

### 1.1 并发(concurrent)

- 一段时间内有多个程序需要执行，其处于启动与执行完毕之间，都在一台处理机上执行，并发中存在两种关系：同步和互斥(排斥临界资源)
- 在单CPU系统中，在某一时刻只能让一个线程运行，系统以时间片轮巡的方式进行线程调度，通过不断切换线程让其运行

### 1.２ 并行(parallel)

- 多个程序在多个处理器上执行，即同一个时刻有多个进程在多个处理器上执行
- 在多cpu系统中，同一时刻可以支持两个以上的线程同时运行

## 2. 同步与异步

- 同步(synchronous)：**顺序执行，需要协调等待**程序执行调用时，调用方得等待这个调用返回结果才能继续往后执行，即顺序执行代码片段；进程间相互依赖；
- 异步(asynchronous)：**彼此独立，互不干扰**和同步相反,调用方不会等待得到结果，而是在调用发出后调用者可用继续执行后续操作，被调用者通过状态来通知调用者，或者通过回调函数来处理这个调用；

## 3. 单线程与多线程

- 线程是cpu资源分配和调度的基本单位
- 多线程是进程中并发运行的一段代码

## 4. 异步与多线程

- 异步与多线程不是对等关系，多线程是实现异步的方式，异步是多线程的最终目的
- **相同点：** 避免线程阻塞、占用系统资源，提高软件的响应性
- **不同点：** 线程不是一个计算机硬件的功能，而是操作系统提供的一种逻辑功能；异步操作无须额外的线程负担，并且使用回调的方式进行处理



## 5. 并发和并行的区别

并发，指的是多个事情，在同一时间段内同时发生了。   

并行，指的是多个事情，在同一时间点上同时发生了。

并发的多个任务之间是互相抢占资源的。   

并行的多个任务之间是不互相抢占资源的、

只有在多CPU的情况中，才会发生并行。否则，看似同时发生的事情，其实都是并发执行的。




并发（concurrency）：把任务在不同的时间点交给处理器进行处理。在同一时间点，任务并不会同时运行。

并行（parallelism）：把每一个任务分配给每一个处理器独立完成。在同一时间点，任务一定是同时运行。




