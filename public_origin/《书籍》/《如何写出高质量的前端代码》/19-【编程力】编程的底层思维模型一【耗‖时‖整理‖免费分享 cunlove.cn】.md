一个优秀的前端工程师，同样也可以很快地学会Python、PHP、Go等语言，并能很好地运用新的编程语言去解决业务问题，为什么会这样呢，明明两个语言的语法完全不一样，为什么他就能很快地迁移到新的语言呢？

从"道法术器"的角度来看，在编程中，底层的思维模型为道，编程原则为法，编程技巧为术，编程语言为器，越是底层的能力其迁移能力越强，和编程语言无关，甚至和职业行业无关，一个具有良好思维模型的人，无论从事什么职业，相信都可以很快做出成绩。

学习优秀的思维模型，可以提升我们对编程的认知，不再局限于一招一式的学习，就像内功心法一样，一旦领悟了，飞花摘叶皆可伤人，本节我们就一起探讨下前端程序员必备的几种思维模型。

抽象思维
====

曾经看到过这么一个段子，如果让你写一个炸毁地球的功能（游戏中的地球，不要当真），那么你不应该直接编写一个炸毁地球的方法，而是应该编写一个炸毁星球的方法，将地球作为参数传进去。我想这就是抽象思维的一种体现，你接到的任务确实是炸毁地球，但如果你不加分析和抽象，直接面向原始任务去做开发，一旦后续任务发生变化，比如领导过几天又突发奇想，要炸毁金星、水星、火星...，那你又要无休止地重复之前的工作。

    //没有抽象，直接面向具体任务进行开发
    function bombingEarth(){
        
    }
    
    //抽象出炸毁星球的方法
    function bombingPlanet(){
        
    }
    //将地球传进去
    bombingPlanet(earth);
    //将火星传进去
    bombingPlanet(mars);
    

抽象思维是一种通用的思维模型，它不仅在工作生活中有很多的应用，对于编程也有很深的影响，比如问题的分解、模块的设计、代码的重用等，都需要我们利用抽象思维来完成这些工作，可以说一个人抽象能力的强弱决定了编程水平的高低。

认识抽象思维
------

### 什么是抽象思维

在百度百科中，关于抽象思维的定义如下：

> 抽象思维作为一种重要的思维类型，是在分析事物时**抽取事物最本质的特性而形成概念，并运用概念进行推理、判断的思维活动**。

从定义可以看出，抽象思维的运用过程主要分为三步：

*   **分析事物**：抽取事物最本质的特性、特征
*   **形成概念**：用一个抽象的词语、概念、公式等来概括多个实体的共同特征
*   **推理判断**：抽象的目的还是为了运用，有了概念之后，可以利用概念来进行一些推理和判断，帮助解决问题

讲到这里，我就很自然地想到了咱们古代数学家和国外数学家对于直角三角形的认知差别，我国古代称直角三角形为勾股形，直角边中较小者为勾，另一长直角边为股，斜边为弦，远在周朝时期的商高就发现了勾三股四弦五这一特例，然而很遗憾，并没有对所有直角三角形进行分析，并得出一个通用的直角三角形规律，直到公元前六世纪，希腊数学家毕达哥拉斯证明了勾股定理，即在平面上的一个直角三角形中，两个直角边边长的平方加起来等于斜边长的平方。

![chouxiang-sanjiaoxing.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5633d58d40fa42ff94a6368cae349075~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=657&h=423&s=32620&e=png&b=fefefe)

可以看出，单纯的"勾三股四玄五"还是停留在对"具像"的认识上，是一种经验，很难进行大范围的应用，而勾股定理，则是对所有直角三角形特点的一种抽象，只要知道直角三角形的任意两条边长度，就可以推理出第三条边的长度，这可以广泛地应用在生产生活中，具有很强的普适性。为什么我们明明很早就发现了直角三角形的特点，但却没有得出这种通用的公式，我觉得这是值得我们思考的。

回到我们的前端开发中，抽象也是无处不在的，以组件抽取为例，如果没有ElementUI、antd等优秀的组件库，在前端开发中，大家也会很容易想到抽象出表格、按钮等组件，事实上在使用jQuery的年代，我们也确实抽象出了这些组件，因为他们很直观，符合具象思维。但是有一些组件如果没有一些抽象能力，是无法轻易设计出来的，比如Grid组件。

前端页面布局确实多种多样，有的两栏均分，有的三栏均分、四栏均分，而有的则分为大小不等的几部分，缺少抽象思维时，我们很容易根据设计图来给每个Div设置宽度值，而这些优秀的组件库都抽象出了栅格（grid）、行（row）、列（col）、间隔（gutter）这样一组概念（不知道谁先提出的），将一行划分为24等份，通过设置col的span值来控制宽度，这样我们就可以很轻松地实现各种布局。

> 题外话：想一想为什么划分为24等份？

### 概念的内涵和外延

前面我们提到，抽象最终会形成概念，而说到概念就不得不谈下它的两个重要属性：内涵和外延。

内涵是指该概念所反映的对象的本质属性的总和，比如平行四边形的内涵就是两组对边分别平行，这就是平行四边形最本质的特点。而外延是概念指称的、具有概念所反映的那些特有属性的一切对象，亦即概念的适用范围，比如平行四边形概念的外延有一般平行四边形、菱形、长方形、正方形。

一个概念的内涵愈广，则其外延愈狭，反之亦然，比如菱形的内涵就比平行四边形的内涵要广，除了要求两组对边分别平行之外，还要求四条边相等，而菱形的外延要比平行四边形的窄，菱形的外延只有菱形和正方形两种图形，而平行四边形外延有四种图形。

形状

内涵

外延

平行四边形

两组对边分别平行

一般平行四边形、菱形、长方形、正方形

菱形

两组对边分别平行，且四条边相等

菱形、正方形

正方形

两组对边分别平行，四条边相等，且四个角为直角

正方形

了解概念的内涵和外延很重要，能够更好地理解对方，在写代码时，如果概念内涵混乱，那么代码的可读性就会受到严重影响，比如客户(customer)和用户(user)，两者就具有不同的内涵。

*   客户：通常指的是在商业交易中具有购买行为的个人或组织
*   用户：指的是使用某种产品或服务的人，无论是否产生直接的商业交易

那么我们在写代码时，就应该用不同的命名来表达不同的用户，明明是用户，却用customer来命名，这显然会带来不必要的误解，增加代码阅读障碍，所以在可读性一节中，建议大家整理一份领域词汇表，明确不同概念的含义，即内涵。

明确概念不只是对命名有影响，还会深层次地影响代码的结构设计，以网上购物为例，当我们购买一个商品时，我们是购买「商品」还是购买「商品下的某个SKU」，这会严重影响我们订单的结构设计，如果对于订单这个基础概念研发和产品经理没有对齐，那么后续将会造成严重的问题。

在研发中一定要特别重视对概念的理解，保证大家对概念内涵和外延的理解是一致的，不至于出现大家各说各的情况，看似是在讨论一件事，实际根本驴唇不对马嘴。

### 抽象的层次

对一个事物进行抽象，得出的概念是可以具有不同层次的，比如我们对波斯猫进行抽象，那么可以抽象出：波斯猫、猫属、猫科、食肉目、哺乳纲、脊索动物门、动物界这7层概念，在讨论波斯猫时，你脑中可能会浮现出一个波斯猫的具体形象，（如果你知道波斯猫长相的话），耳朵尖而小，鼻子短，眼睛大而圆...而当讨论猫属时，脑中则可能只剩下一个大致的猫的轮廓了，没有那么多细节，而当讨论动物时，则脑中很难包括很多细节。

![chouxiang-mao.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70d7d494b2a34e0d84cce6e0acffe5cb~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=326&h=443&s=27964&e=png&b=fefefe)

随着抽象层次的提升，概念的内涵越来越小，外延越来越大，但是细节越来越少。

那是不是抽象的层次越高越好呢？也不一定，比如现在领导让做一个word文档预览功能，我们可以对预览这个事情进行抽象，比如抽象成为以下几个层次：word文档预览、office文档预览、文档预览和文件预览。

![chouxiang-preview.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab9e02cf21b048bbadc1a41f5dfd1959~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=856&h=400&s=64224&e=png&b=fefefe)

假设每个层次的抽象通过一个组件实现，那么对应的组件功能如下：

*   word文档预览组件(DocxPreview)：只支持word文档的预览
    *   可以设置的属性包括：文档url、宽高、**word分页的处理方式**、word文档的默认字体、默认主题、是否支持虚拟列表等
*   office文档预览(OfficePreview)：支持office办公文档（word、excel、ppt等）的预览
    *   可以设置的属性包括：文档url、宽高、默认主题、是否支持虚拟列表等
*   文档预览(DocumentPreview)：支持office文档、markdown文档、pdf文件的预览
    *   可以设置的属性包括：文档url、宽高等
*   文件预览(FilePreview): 支持各种文件预览，包括office文件、音视频文件、图片文件等
    *   可以设置的属性包括：文档url、宽高等

随着抽象层次的提升，组件的通用性越来越强，适用的场景越来越多，也就是外延越来越大，但是细节也丢失的越来越多，比如word文档预览组件中，会针对word的特点增加一些特殊属性，比如word分页的处理方式、word文档的默认字体、默认主题等，但是如果是一个文件预览组件，则不适合传递这些属性，因为对于其他文件（如音视频）根本没有这些属性。而且随着抽象层次的提高，组件实现的复杂度也越来越高，领导让你实现word预览，而你去封装一个文件预览组件，很可能会被领导认为脑子有问题~

但是如果你要做一个开源的文件预览库，那么抽象层次稍微高一些，你的受众就会更广，也会容易收到更多的star，所以并不是说抽象层次越低越好，也不是说抽象层次越高越好，适合的才是最好的。

抽象思维在前端开发中的运用
-------------

### 更好地组织代码

从大的方面说，前端开发技术的发展伴随着对UI页面的认知升级，从 jQuery 到 React 、Vue 等现代框架，前端页面**概念**的内涵其实发生了一些变化。在 jQuery 时代，页面通常被视为一系列 DOM 元素的集合，开发者通过直接操作这些 DOM 元素来实现页面的交互和动态效果。而在现代前端框架中，页面的概念更多地被抽象为组件化的视图单元。页面被拆分为多个独立的组件，每个组件负责自己的状态管理和渲染逻辑，组件之间通过数据流进行通信和交互。这种组件化的概念使得页面的代码结构更加模块化和灵活，同时也提高了代码的复用性和可维护性。

对于一个项目的代码组织，抽象思维仍然发挥着巨大作用，可以说只要看一眼你的项目目录，就知道你是否具有很好的抽象思维。没有经过抽象的项目目录是混乱的，可能是多个目录内涵上有交叉，也可能某个目录下放置了不应该存放的文件，又或者是所有的内容杂糅到一个文件中，总之，目录结构就是对项目内容进行抽象的一个外在表现，就和一本书的大纲一样重要。

在本小册开头我们就讲到了怎么组织一个清晰的代码结构，我们将整个项目内容抽象成了三大层：基础层、领域层和应用层，每一层都有明确的职责和边界（概念的内涵）。

![level.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6bc285396d6403a83b996dbc33b9721~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=508&h=457&s=24260&e=png&b=fefefe)

还有就是经常诟病的超大utils.js的问题，我发现很多人喜欢把各种各样的方法都一股脑地放进这个文件中，本质上这是抽象不足导致的。因为不知道该把哪几个方法单独提取到一起，也不知道提取后应该起一个什么样的名称（名称意味着抽象的概念），所以最后也懒得抽取了，干脆都放到utils中，最终成了一个大杂烩。

除去目录的划分，在代码编写时，抽象思维仍然发挥作用。不知道你发现没有，当我们阅读大佬的源码时，经常会发现一些Class类，也就是使用面向对象的方式来进行一些功能的开发，而这里的对象，其实就是抽象出来的概念，它不是天然存在直接摆在你面前的，而是必须要经过分析思考抽象才能得出。很多小白开发在写代码时往往都是按照直观思路来，页面长什么样我就创建什么样的Dom，然后给Dom设置事件监听等等，都在面向过程开发。

就像前面我们举过一个低代码编辑器的示例，我们就抽取出来了数据模型DataModel、画布Graphview、节点Node、历史管理HistoryManager等多个不同的类，每个类有不同的职责，通过这种划分后，每个类的实现反而变的非常简单，因为它足够纯粹，只要完成既定的职责就可以了。

可以说抽象思维融入在前端开发的方方面面，可以更好地指导我们如何组织代码。

### 提升代码复用性

前面我们提到过，抽象的层次越高，其外延越大，外延越大意味着覆盖的场景越多，也就是复用性越强，这比较好理解，就像前面我们提到的word预览组件WordPreview和文件预览组件FilePreview，文件预览组件的抽象层次要更高，复用性肯定要更好。

还记得我们在前面提升复用性一节中提到的例子吗？删除产品时需要用户输入产品的名称进行二次确认，输入正确后才能进行删除，于是针对这个业务场景封装了一个删除产品确认组件DeleteProductConfirm， 该组件对外提供了一个showDialog方法，参数为产品名称(productName)。

    <template>
      <DeleteProductConfirm ref="DeleteProductConfirm"/>
    </template>
    <script>
    export default {
        methods:{
            deleteProduct(product){
                //在删除产品时，调用组件进行二次确认
                this.$refs.DeleteProductConfirm.showDialog({
                  productName: product.name
                }).then(()=>{
                    //进行产品删除操作
                })
            }
        }
    }
    </script>
    

这个删除确认弹窗只能在删除产品时可以使用，假如删除用户时也需要输入用户名称进行二次确认，那这个组件就无法使用了，首先弹窗的title肯定不合适，删除产品确认组件中弹窗标题固定为"删除产品确认"，其次在调用showDialog方法时传递的参数key为productName，这在删除用户的场景中就会显得非常怪异。

显然，这个组件没有进行抽象，只是针对当前具体业务场景进行了封装，导致组件的应用场景受限。让我们来分析下，删除用户确认和删除产品确认有一些共同点，都是在弹窗中让用户输入要删除的资源名称，只有输入的资源名称和要删除的一致，才允许进行删除，我们可以将抽象升级，把删除产品确认组件（DeleteProductConfirm）升级为危险删除确认组件（DangersDeleteConfirm），使用组件时传递参数包括弹窗标题title和确认值value。

    <template>
      <DangersDeleteConfirm ref="DangersDeleteConfirm"/>
    </template>
    <script>
    export default {
      methods: {
        //删除产品和删除用户可以复用这个组件
        deleteProduct(product) {
          this.$refs.DangersDeleteConfirm.showDialog({
            title: "删除产品确认",
            value: product.name
          })
        },
        deleteUser(user) {
          //在删除产品时，调用组件进行二次确认
          this.$refs.DangersDeleteConfirm.showDialog({
            title: "删除用户确认",
            value: user.name
          })
        }
      }
    }
    </script>
    

现在需求又有了一些新的变化，产品要求销毁应用的时候也需要二次确认，虽然上面实现的组件在功能上也可以满足需求，但是上面的组件名称叫做Dangers**Delete**Confirm，这里突出的是Delete操作，而我们这里进行的是销毁操作(Destroy)，强行使用显然不太合适，这里还需要再进行一次抽象。删除确认和销毁确认都是对危险操作的确认，那我们是不是可以将组件名称改为DangersOperationConfirm呢？这样无论是删除、销毁还是迁移等等危险操作，都可以复用这个组件，而我们只是把组件的名称改一下而已，并没有对内部实现进行修改，仅仅是做了抽象的层次的提升。

通过这个示例我们可以看到，随着抽象层次的提升，组件的复用性越来越好，同理，如果你发现组件的复用性不好，那就应该思考下是不是抽象层次不够高，是否需要进一步抽象。

虽然抽象层次提高会让组件的复用性越好，但是是否需要一上来就进行高层次的抽象还要视情况而定，这里我觉得可以参考这三个原则：

*   YAGNI原则：You aren't gonna need it ，不要过度设计，只对当前需要解决的问题进行抽象，针对上面这个示例，如果刚开始只有删除产品确认的需求，那么封装一个删除产品确认组件（DeleteProductConfirm）也无可厚非。
    
*   DRY原则：Don't repeat yourself，不要重复自己，当后续出现了删除用户确认的需求后，我们需要对之前封装的组件进行重构，将删除产品确认组件（DeleteProductConfirm）升级为危险删除确认组件（DangersDeleteConfirm），然后对原有代码进行重构。
    
*   Rule Of Three原则：当某个功能第三次出现时，才进行"抽象化"，这个原则有点像我们经常说的事不过三，第一次出现某个需求，直接实现它，第二次出现这个需求，复制粘贴它，第三次出现时，进行抽象并重构，这样更省事，而且抽象时也容易找到共性。
    

如何提升抽象思维
--------

要提升某项能力，无外乎多看、多想、多练，提升思维能力也无外如是。

### 多看：

要想提升抽象思维，那就要多看看别人是怎么抽象，看得多了遇到类似的问题才能想到借用。

比如每隔一段时间就看看大佬们的源码，看看大佬们是如何组织代码的，他们的目录结构是怎么规划的，都设计了哪些类，每个类的定位是什么。

还可以看看业界优秀的产品，比如前端组件库Element、AntDesign等，看看人家的设计思想设计原则，都抽取了哪些组件，每个组件的API是怎么设计的。

### 多思考总结

抽象本身就是一个复杂的思维活动，必然需要进行深度的思考，抽象并不是简单的提取共性，还需要反复的推演，来思考自己建立的概念模型是不是真的合理，有哪些优缺点，经过反复的长时间的推演才可能得到一个比较好的模型，就像上面提到的低代码编辑器，我们抽象的这些概念从UI图中是完全看不出来的，这也是抽象比较难的地方。

总结的过程，就是锻炼我们提炼能力的过程，平时阅读源码或者学习新技术，异或是对编程有了什么见解，都可以试着总结出来，构建自己的认知体系，这对提升我们的思维是非常重要的。

### 多练

站在岸边是永远也学不会游泳的，只有真正在水中游过，被呛到过才能真正学会游泳，锻炼思维这种比较虚的能力更是如此。

比如日常编程中的命名就是很好地锻炼抽象思维的能力，一个好的命名可不是唾手可得的，命名本身就是一种抽象，用一个简短的词表达一个复杂的概念，这需要很深的抽象功底，从今天起开始重视命名吧。

另外就是不要害怕代码重构，特别是当代码有重复时，你就要知道锻炼抽象的好机会来了，解决重复代码并不只是简单的进行提取，更要注意是不是在概念上有所提升，并记得给这个概念取一个合适的名字。

结构化思维
=====

在工作中遇到的最难维护的代码，一般都有个明显的共同特点，那就是几乎都是几千行以上，甚至上万行，导致想要梳理清楚其中的逻辑非常困难，读都读不明白，更别谈维护了。虽然说小的代码不一定是好代码，但是超大的代码一定不是好代码，背后反映了作者的模块化能力较差，缺少结构化的思考。

在之前的文章中，我提到过一个观点，那就是一个页面的行数建议不超过300行，为了印证我这个观点，我特意写了个小脚本对前端大佬的源码进行了分析，结果如下：

库

小于100行占比

小于200行占比

小于300行占比

小于500行占比

平均行数

最大行数

备注

vue

60.8%

84.5%

92.6%

98.0%

112

1000

仅1个模板文件编译的为1000行

react

78.0%

92.0%

94.0%

98.0%

96

1341

仅1个JSX文件编译的为1341行

element-plus

73.6%

90.9%

95.8%

98.8

75

950

ant-design

86.9%

96.7%

98.7%

99.5%

47

722

> 排除了css样式文件以及测试文件

可以看出95%左右的文件行数都不超过300行，而且每个库中超过千行以上的文件最多也只有一个，而且还都是最复杂的模板文件编译相关的代码，我们平时写的业务代码复杂度远远小于这些优秀的库，那为什么我们写的代码总是那么冗长呢？核心还是缺少结构化的思考，没有学会利用结构化思维去拆解问题，总是一味地面向细节在编程，把所有逻辑混在一起，导致代码越来越冗长，最终造成代码的可读性、复用性、可维护性等都大大降低，严重降低了研发效率。

除了超大的代码文件外，另外一种较难维护的代码就是逻辑混乱，条理不清，各个模块之间互相牵扯，产生这些问题的本质也都是缺少结构化思维，结构化思维是影响代码质量的另一个非常重要的思维模式。

认识结构化思维
-------

### 为什么需要结构化思维

我们先来做一个小测试，下面有10个A-Z字母，请在阅读一遍后尝试背诵出来。

> J A F I H G C E B D

怎么样，背下来了吗，如果真的背下来了，那你太厉害了！再试试下面这个呢？

> J A F I H G

这次是不是比较容易就背下来了，美国心理学家乔治·A·米勒在他的论文《奇妙的数字 7±2》中指出，人类短期记忆的容量大致在5到9个项目之间，平均为7个项目，这一理论在生活中有很多应用，比如我们平时收到的短信验证码、快递取件码大都只有6位，导航菜单通常也不会超过7个，如果太多会通过合并增加层级的方式将其缩小。

通过这个小测试我们可以得出一个结论：**人的大脑不适合一次性处理过多的内容**。

现在我们针对上面10个字母做一个排序，然后再看看你是否能一遍背诵出来。

> A B C D E F G H I J

相信只要是学过英语的人，都能很快的背下来，同样是10个字母，为什么刚开始很难背下来，而现在只要看一眼就能背下来呢？

因为第一组测试内容是混乱的无序的，而第二组是清晰的有序的，按照顺序结构排列的，对于大脑来说，记住第一组需要记住10个信息单元，而第二组则只需要记住2个信息单元，即字母包含A-J，顺序为升序，所以大脑可以很快记住。

通过这个测试我们可以得出，**大脑更喜欢有规律、有结构的信息**。

如果我们写的代码逻辑是混乱的，那么在阅读代码时，需要记忆的信息量就会显著增大，再加上没有进行合理的拆分，一个文件几千行，试问要怎样的大脑容量才能理解这么多信息呢？这也是为什么我们要通过结构化的方式去写代码。

### 什么是结构化思维

关于结构化思维的定义，我目前还没有看到一个公认的权威的定义，我觉得结构化思维可以从两个方面来理解：任务拆解（自上而下）和总结汇报（自下而上）。

#### 1\. 任务拆解：

在面对一个较大的任务或者主题时，将复杂的问题分解成为更小的子任务，且这些子任务之间存在一定的逻辑关系，可以看做是自上而下的梳理结构的过程。这类情况下，一般我们的目标是确定的，我们需要把大目标拆解成可执行的小模块。

我们通过一个情景模拟来理解下拆解的重要性，假设你现在是个前端小组长，有一天你的领导把你叫到办公室，让你调研下为什么最近前端代码质量变差了。在接收到这个任务之后，你会怎么做呢？直接去找前端同学问为什么前端代码质量变差了吗？当然不是这样，这样做事是没有章法的，很难让领导满意，我们需要对这个大的任务进行拆解。

我们可以按照解决问题的顺序将调研"最近前端代码质量变差了"这个任务拆分为：确定问题、分析原因、制定解决方案、总结汇报四大模块，然后再对每个小块进行拆解。

![jiegou-zhiliang1.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b4d5ccd1a0f4feaabb875575799952a~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=735&h=270&s=29294&e=png&b=ffffff)

*   确定问题：

确定问题可以再细化为两部分：领导说的前端代码**质量**指的是什么？**最近**代码质量真的变差了吗？

通过对最近公司发生的事情的了解或者直接和老板沟通得知，领导说的是前端代码质量问题是指最近出现了多次线上事故，并不是说的前端代码可读性、复用性等不好。 而且通过对比发现最近三个月的线上事故数量，发现最近一个月前端线上事故确实比之前增加了，领导说的问题确实存在。

*   分析原因：

确定问题之后接下来想办法分析前端代码质量变差的原因，这里还可以再分解为几个具体的措施，比如组织最近一个月的前端线上事故复盘会、和其他前端同学进行1对1沟通、Review近期前端代码等。

*   制定解决方案

领导问的是最近前端代码质量为什么下降了，但是实际目的肯定是想要提高代码质量，所以不能到分析原因这一步就停止了，还要制定详细的解决方案，制定解决方案同样需要结构化思维，后面详细展开。

*   总结汇报：

靠谱的员工需要做到凡事有交代，件件有着落，事事有回音，在做完领导交代的任务后，必须进行总结汇报，而怎么总结汇报也需要结构化思维。

好了，通过这样的拆解，我们对于怎么完成这个调研任务心中有了一个清晰的结构，做起事来也能从容不迫，只需要按照规划的节点一步一步推进就行，不用担心遗漏一些重要节点，而且可以通过审视我们这个结构来发现问题，比如我们的这个方案能保证我们找到最近前端代码质量变差的根本原因吗？

#### 2\. 总结汇报：

理解结构化思维的另一个维度就是总结汇报，在这种场景下，利用结构化思维是指将搜集到的无序的信息，按一定的逻辑进行分析、归纳，最终呈现出一种有序的结构。

仍然延续上面的例子，在通过对前端线上事故的复盘及1对1沟通后，你找到了一些引起前端代码质量下降的原因及出现次数。

![jiegou-yuanyin1.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76e4145c833449b4be4831832f719eb4~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=700&h=331&s=49055&e=png&b=fefefe)

那么我们能拿这个结果去直接给领导看吗，显然还不行，这里的内容太散了，都是一些点状信息，之间没有逻辑性，我们需要对其中的内容进行一些分析、归类。

![jiegou-yuanyin2.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f890dab2f004bfd8a91c05faf8fb4ab~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=709&h=568&s=82462&e=png&b=ffffff)

如图，我们总结出了几大类问题：设计问题、测试问题、CodeReview问题、排期问题和新人培养问题，到这里还不够，我们还可以继续按照这个思路去总结，设计、排期、测试、CodeReview属于研发流程，而新人培养我们可以归结为新人培养流程，研发流程和新人培养流程我们可以归结为工作流程问题，好了，这样我们就可以把最近的前端质量问题归结为如下形式：

![jiegou-yuanyin3.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95805f416af64f9888e6b97230ac69af~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=727&h=341&s=35792&e=png&b=ffffff)

现在可以给领导汇报原因了，领导你看这个图，最近一个月出现的质量问题主要集中在我们的研发流程上，特别是前端设计和测试这两个环节，在CodeReview和排期环节也有少量问题，另外我们的新人培养流程目前是缺失的。怎么样，这样的汇报是不是比直接把所有原因丢给领导要好很多，这就是结构化思维的魅力所在。

而且在构建出整个结构之后，我们还可以通过结构审视下有哪些缺失内容，比如新人培养流程除了培训前端公共技术，是不是还可以增加工作流程培训、产品培训等，这样也能保证我们的思考更加全面。

通过这个示例可以看出，无论是自上而下拆解还是自下而上总结，结构化思维都能很好地帮助到我们。

### 常见结构

#### 金字塔结构

在麦肯锡经典培训教材中，有一本非常著名的书：《金字塔原理》，可以说是结构化思维的圣经。金字塔原理是一种重点突出、逻辑清晰、主次分明的逻辑思路、表达方式和规范动作。

金字塔的基本结构是：中心思想明确，结论先行，以上统下，归类分组，逻辑递进。先重要后次要，先全局后细节，先结论后原因，先结果后过程。

![jiegou-jinzita.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5afbee2557184116aabcf81e1625b3ca~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=794&h=445&s=48350&e=png&b=ffffff)

在纵向上体现的是层次关系，这里特别要注意，上一层一定能够统领下一层，否则就会造成逻辑不清，比如在水果下面放一个菠菜，你是不是觉得很可笑，但是当我们写代码时却是经常会犯这样的错误。

![jiegou-jinzita2.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b521b0d3d22b4260ae441c0cd62306d2~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=313&h=233&s=11512&e=png&b=ffffff)

看看下面的代码，getData作为上层方法，能统领下面的子方法吗？

    function getData(){
        getUserData();
        initFormData();      //getData能涵盖这里的逻辑吗
        clearFormValidate(); //getData能涵盖这里的逻辑吗
    }
    

在横向上，我们要注意两点：

*   横向的元素之间必须属于同一个逻辑范畴，并按照某种顺序来组织。比如时间顺序、空间顺序、程度顺序。
*   横向元素之间应该满足MECE原则，即相互独立且完全穷尽，既不能遗漏某些元素，也不能让元素之间互相覆盖

#### 5W2H分析法

5W2H分析法又叫七问分析法，创于二战中美国陆军兵器修理部。简单、方便，易于理解，实用，富有启发意义，广泛用于企业管理和技术活动，对于决策和执行性的活动措施也非常有帮助，也有助于弥补考虑问题的疏漏。

所谓5W2H即5个单词的首字母：

*   WHAT——是什么，目的是什么，做什么工作。
*   WHY——为什么要做，可不可以不做，有没有替代方案。
*   WHO——谁，由谁来做。
*   WHEN——何时，什么时间做，什么时机最适宜。
*   WHERE——何处，在哪里做。
*   HOW ——怎么做，如何提高效率，如何实施，方法是什么。
*   HOW MUCH——多少，做到什么程度，数量如何，质量水平如何，费用产出如何。

![jiegou-5w2h.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/531f9e7366dc4e9cb249438fcf6da2fe~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=438&h=370&s=48505&e=png&b=ffffff)

在分析问题时，我们可以套用这个模型，避免考虑问题时产生遗漏。

比如我们准备通知前端同学复盘下最近一个月的线上故障，你可能需要给大家发个参会通知：

> 大家好，请于今天下午4点到5点到A1会议室参加线上故障复盘会，主要议程是讨论近1个月的线上事故产生原因，找到提升前端代码质量的解决方案。

这样的通知不够清晰，内容不够结构化，接下来我们用5W2H方法重新整理下：

> 会议主题（What）：前端近1个月线上故障复盘会
> 
> 会议举办原因（Why）：近1个月前端线上故障激增
> 
> 会议目标（How much）：找到提升前端代码质量的解决方案
> 
> 时间(When)：今天下午4点-5点
> 
> 地点(Where)：A1会议室
> 
> 参会人员(Who)：所有前端同学、测试、产品经理
> 
> 会议议程(How)：1.线上故障case梳理 2.讨论解决方案

怎么样，通过这种固定的模式，再也不用担心自己做事会落下什么了，让你分析事情从思考题变成了填空题，这也是熟悉结构的原因。

#### SWOT 模型

所谓SWOT分析，即基于内外部竞争环境和竞争条件下的态势分析，就是将与研究对象密切相关的各种主要内部优势、劣势和外部的机会和威胁等，通过调查列举出来，并依照矩阵形式排列，然后用系统分析的思想，把各种因素相互匹配起来加以分析，从中得出一系列相应的结论，而结论通常带有一定的决策性。

运用这种方法，可以对研究对象所处的情景进行全面、系统、准确的研究，从而根据研究结果制定相应的发展战略、计划以及对策等。

S （strengths）是优势、W （weaknesses）是劣势、O （opportunities）是机会、T （threats）是威胁。按照企业竞争战略的完整概念，战略应是一个企业“能够做的”（即组织的强项和弱项）和“可能做的”（即环境的机会和威胁）之间的有机组合。

![jiegou-swot.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db9cbb79f27441e0b8285f8762a4afe2~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=479&h=318&s=18779&e=png&b=d3865a)

#### SMART 模型

SMART模型是一种目标设定和评估框架，它由五个英文单词的首字母组成，分别是：Specific（具体）、Measurable（可度量）、Achievable（可实现）、Relevant（相关性）、Time-bound（有时限）。这个模型用于确保目标设定得既明确又可操作，从而帮助个人或组织有效地规划和达成目标。12

*   Specific（具体）：目标必须是清晰、具体的，避免使用模糊或笼统的描述。具体性有助于确保各方对目标的理解一致。
    
*   Measurable（可度量）：目标应该是可以量化的，即能够通过数量或行为来衡量目标的进展和完成情况。
    
*   Achievable（可实现）：目标应该是实际可行的，即在付出努力的情况下可以达到的。避免设定过高或过低的目标，以免失去激励作用。
    
*   Relevant（相关性）：目标必须与组织的战略或个人的长期规划相关联，确保目标是值得追求的。
    
*   Time-bound（有时限）：目标应包含特定的完成时间，这有助于设定优先级和确保目标的及时完成。
    

SMART模型的应用非常广泛，不仅适用于个人目标的设定，也适用于项目管理、组织战略规划等多个领域。通过遵循SMART原则，可以确保目标的明确性、可操作性和可达成性，从而提高个人和组织的绩效。

#### 四象限法则

四象限法则是时间管理理论的一个重要方法，即有重点地把主要的精力和时间集中地放在处理那些重要但不紧急的工作上，这样可以做到未雨绸缪，防患于未然。

![jiegou-sixiangxian.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c3281aed7864932905bf0c3db9e82d3~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=622&h=496&s=45053&e=png&b=ffffff)

*   第一象限

这个象限包含的是一些紧急而重要的事情，这一类的事情具有时间的紧迫性和影响的重要性，无法回避也不能拖延，必须首先处理优先解决。它表现为重大项目的谈判，重要的会议工作等。但是如果你总是有紧急又重要的事情要做，说明你在时间管理上存在问题，设法减少它。

*   第二象限

第二象限包含的事件是那些紧急但不重要的事情，这些事情很紧急但并不重要，因此这一象限的事件具有很大的欺骗性。很多人认识上有误区，认为紧急的事情都显得重要，实际上，像无谓的电话、附和别人期望的事、无效的酒局社交等事件都并不重要。这些不重要的事件往往因为它紧急，就会占据人们的很多宝贵时间。这类事情可以考虑授权给别人去做。

*   第三象限

第三象限的事件大多是些琐碎的杂事，没有时间的紧迫性，没有任何的重要性，这种事件与时间的结合纯粹是在扼杀时间，比如每天无休止的刷短视频，这件事并不紧急也不重要，但是却占据了大部分人的空闲时间。我的建议时，在精力旺盛时先做一些重要的事，比如学学习、看看书、陪伴下家人等，在疲惫时可以适当刷一会休闲下，尽量少做这些事。

*   第四象限

第四象限不同于第一象限，这一象限的事件不具有时间上的紧迫性，但是，它具有重大的影响，对于个人或者企业的存在和发展以及周围环境的建立维护，都具有重大的意义。学习就属于这一类，学习不是一天的事情，所以好像今天不学也没什么影响，很容易被人忽视，但是如果没有计划去做，等到需要用到时，比如突然被裁员了，就只能临时抱佛脚了。这类事情建议制定计划去做，这类事情做多了，也就不会出现那么多重要且紧急的事情了。

结构化思维在前端开发中的运用
--------------

### 开发过程中的运用

开发过程对应我们前面提到的任务拆解过程，在进行某个功能开发时，不是上来就平铺所有细节，而是先把功能的结构定下来，然后再依次去填充每个结构的内容。

以开头提到的统计源代码的行数的脚本为例，来看看怎么通过结构化的方式去开发代码。需求内容：给定一个目录，要求统计出目录下文件行数的最小值、最大值、平均值、小于100/200/300/500行的比例，忽略node\_modules、测试文件以及样式文件。

在接到这个任务时，先不要着急开发，我们先来分析下，要完成这样一个功能应该分为几步，我认为可以划分为四部分：首先获取给定目录下的所有文件，然后获取每个文件的行数信息，接着统计我们想要的数据，最后把统计结果打印到控制台。

![jiegou-script1.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c66a2fe1c4a54c32af6bd4d0dc4165df~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=547&h=173&s=17979&e=png&b=ffffff)

根据这个结构图，我们先把脚本的整体结构给编写出来，如下，这个时候不需要实现任何一个函数，只要先声明下即可，相当于每个函数都是一个todo项，后续我们补充实现即可。

    const fs = require('fs');
    const path = require('path');
    
    let fileList = [];       //存放文件路径
    let fileLengthMap = {};  //存放每个文件的行数信息
    let result = {           //存放统计数据
        min: 0,
        max: 0,
        avg: 0,
        lt500: null,
        lt300: null,
        lt200: null,
        lt100: null
    }
    //收集所有文件路径
    function collectFiles(){
    
    }
    
    //获取每个文件的行数
    function readFilesLength(){
        
    }
    
    //统计
    function statistics(){
        
    }
    
    //打印
    function print(){
        
    }
    
    //源码行数统计
    function main(path){
        collectFiles(path);
        readFilesLength();
        statistics();
        print();
    }
    
    main(path.resolve(__dirname,'./vue-main/src'))
    

接下来我们开始实现收集所有文件路径的函数collectFiles，要找到一个目录下的所有文件涉及对一个树的遍历，树的遍历经常使用的方法有两种，一种是递归，一种是通过while循环，这种基本的数据结构和算法知识必须要牢牢掌握；在遍历过程中需要判断一个路径是文件还是目录，并且还要判断该路径是否应该被忽略，如果该路径是目录还要获取它的子文件加入遍历，为此我们可以再提取3个小方法isFile、shouldIgnore、getFilesOfDir。

![jiegou-script2.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c102c49c658f4bf89cee5faa24655668~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=839&h=254&s=31398&e=png&b=ffffff)

collectFiles的实现如下，为了检验我们实现的是否正确，可以在print方法中，把获取到的文件路径打印出来。

    function collectFiles(sourcePath){
        //判断路径是否为文件
        const isFile = function (filePath){
            const stats = fs.statSync(filePath);
            return stats.isFile()
        }
        //判断是否应该忽略
        const shouldIgnore = function (filePath){
            return filePath.includes("__tests__")
                || filePath.includes("node_modules")
                || filePath.includes("output")
                || filePath.includes("scss")
                || filePath.includes("style")
        }
        //获取目录下子文件
        const getFilesOfDir = function (filePath){
            return fs.readdirSync(filePath)
                .map(file => path.join(filePath, file));
        }
    
        //利用while实现树的遍历
        let paths = [sourcePath]
        while (paths.length){
            let fileOrDirPath = paths.shift();
            if(shouldIgnore(fileOrDirPath)){
                continue;
            }
            if(isFile(fileOrDirPath)){
                fileList.push(fileOrDirPath);
            }else{
                paths.push(...getFilesOfDir(fileOrDirPath));
            }
        }
    }
    
    function print(){
      console.log(fileList)
    }
    

获取到所有文件的地址后，接下来就是计算每个文件的行数，这个实现很简单，不再赘述，readFilesLength方法实现如下，同样地，在print方法中把结果打印出来，方便我们检查实现是否正确。

    function readFilesLength(){
        fileList.forEach((filePath) => {
            const data = fs.readFileSync(filePath, 'utf8');
            const lines = data.split('\n').length;
            fileLengthMap[filePath] = lines;
        })
    }
    function print(){
      console.log(fileList)
      console.log(fileLengthMap)
    }
    

接下来是重头戏，开始进行数据统计，有的同学可能会说我通过对获取的文件行数数据fileLengthMap进行一次遍历，然后把所有需要统计的信息一次性计算出来不就行了吗，但我建议我们还是把每个统计任务拆开，按照单一职责原则去实现每个统计，按照这个思路统计工作拆分为：统计最小值、统计最大值、统计平均值、统计低于100行的百分比...

![jiegou-script3.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b04c664e5f1441b79cdafb46578b119b~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=936&h=260&s=32079&e=png&b=ffffff)

按照这个思路，统计工作变的非常简单，同样地我们可以先写几个空的统计函数占位，然后再依次实现即可。

    function statistics(){
        statisticalMin();
        statisticalMax();
        statisticalAvg();
        statisticalLt500();
        statisticalLt300();
        statisticalLt200();
        statisticalLt100();
    }
    

最后，统计一个目录下的文件行数的脚本完整实现如下，可以看到无论是可读性、可维护性还是可扩展性都非常好，比如现在想统计一下小于1000行的文件占比，你是不是可以很轻松地实现出来，这就是结构化编程的好处。

    const fs = require('fs');
    const path = require('path');
    
    let fileList = [];       //存放文件路径
    let fileLengthMap = {};  //存放每个文件的行数信息
    let result = {           //存放统计数据
        min: 0,
        max: 0,
        avg: 0,
        lt500: 0,
        lt300: 0,
        lt200: 0,
        lt100: 0
    }
    //收集所有路径
    function collectFiles(sourcePath){
        const isFile = function (filePath){
            const stats = fs.statSync(filePath);
            return stats.isFile()
        }
        const shouldIgnore = function (filePath){
            return filePath.includes("__tests__")
                || filePath.includes("node_modules")
                || filePath.includes("output")
                || filePath.includes("scss")
                || filePath.includes("style")
        }
        const getFilesOfDir = function (filePath){
            return fs.readdirSync(filePath)
                .map(file => path.join(filePath, file));
        }
    
        //利用while实现树的遍历
        let paths = [sourcePath]
        while (paths.length){
            let fileOrDirPath = paths.shift();
            if(shouldIgnore(fileOrDirPath)){
                continue;
            }
            if(isFile(fileOrDirPath)){
                fileList.push(fileOrDirPath);
            }else{
                paths.push(...getFilesOfDir(fileOrDirPath));
            }
        }
    
    }
    
    //获取每个文件的行数
    function readFilesLength(){
        fileList.forEach((filePath) => {
            const data = fs.readFileSync(filePath, 'utf8');
            const lines = data.split('\n').length;
            fileLengthMap[filePath] = lines;
        })
    }
    
    function statisticalMin(){
        let min = Infinity;
        Object.keys(fileLengthMap).forEach((key) => {
            if (min > fileLengthMap[key]) {
                min = fileLengthMap[key];
            }
        })
        result.min = min;
    }
    function statisticalMax() {
        let max = 0;
        Object.keys(fileLengthMap).forEach((key) => {
            if (max < fileLengthMap[key]) {
                max = fileLengthMap[key];
            }
        })
        result.max = max;
    }
    function statisticalAvg() {
        let sum = 0;
        Object.keys(fileLengthMap).forEach((key) => {
            sum += fileLengthMap[key];
        })
        result.avg = Math.round(sum / Object.keys(fileLengthMap).length);
    }
    function statisticalLt500() {
        let count = 0;
        Object.keys(fileLengthMap).forEach((key) => {
            if (fileLengthMap[key] < 500) {
                count++;
            }
        })
        result.lt500 = (count / Object.keys(fileLengthMap).length * 100).toFixed(2) + '%';
    }
    function statisticalLt300() {
        let count = 0;
        Object.keys(fileLengthMap).forEach((key) => {
            if (fileLengthMap[key] < 300) {
                count++;
            }
        })
        result.lt300 = (count / Object.keys(fileLengthMap).length * 100).toFixed(2) + '%';
    }
    function statisticalLt200() {
        let count = 0;
        Object.keys(fileLengthMap).forEach((key) => {
            if (fileLengthMap[key] < 200) {
                count++;
            }
        })
        result.lt200 = (count / Object.keys(fileLengthMap).length * 100).toFixed(2) + '%';
    }
    function statisticalLt100() {
        let count = 0;
        Object.keys(fileLengthMap).forEach((key) => {
            if (fileLengthMap[key] < 100) {
                count++;
            }
        })
        result.lt100 =  (count / Object.keys(fileLengthMap).length * 100).toFixed(2) + '%';
    }
    //统计
    function statistics(){
        statisticalMin();
        statisticalMax();
        statisticalAvg();
        statisticalLt500();
        statisticalLt300();
        statisticalLt200();
        statisticalLt100();
    }
    
    //打印
    function print(){
        console.log(fileList)
        console.log(fileLengthMap)
        console.log('最长行数：', result.max);
        console.log('最短行数：', result.min);
        console.log('平均行数：', result.avg);
        console.log('小于500行的文件占比：', result.lt500);
        console.log('小于300行的文件占比：', result.lt300);
        console.log('小于200行的文件占比：', result.lt200);
        console.log('小于100行的文件占比：', result.lt100);
    }
    function main(path){
        collectFiles(path);
        readFilesLength();
        statistics();
        print();
    }
    
    main(path.resolve(__dirname,'./vue-main/src'))
    

### 重构过程中的运用

代码重构的过程，就是把无序变为有序的过程，和我们前面讲到的结构化思维的总结汇报过程正好完全相符，与上面刚刚演示的代码拆解正好是反过来的。

就比如下面这个简单的示例，一个官网的首页可能包含顶部信息、Banner、关于我们、联系我们和底部信息，没有利用结构化思维开发可能的实现如下：

    <div>
      <div class="header">
        <img src="logo.png"/>
        <h1>网站名称</h1>
        <!--  其他头部代码    -->
      </div>
      <div class="main-content">
        <div class="banner">
          <ul>
            <li><img src="banner1.png"></li>
            <!--   省略n行代码      -->
          </ul>
        </div>
        <div class="about-us">
          <div>发展历程：</div>
          <!--   省略n行代码      -->
          <div>产品介绍：</div>
          <!--   省略n行代码      -->
          <div>创始团队：</div>
          <!--   省略n行代码      -->
        </div>
        <div class="contact-us">
          <div>
            <span>技术支持：</span> <span>156-8888-9999</span>
          </div>
          <div>
            <span>大客户合作：</span> <span>156-8888-9999</span>
          </div>
          <div>
            <span>售后支持：</span> <span>156-8888-9999</span>
          </div>
        </div>
        <!--   省略n行代码      -->
      </div>
      <div class="footer">
        <div>备案信息：</div>
        <!--   省略n行代码      -->
        <div>友情链接：</div>
        <!--   省略n行代码      -->
      </div>
    </div>
    

这个示例太简单了，我们稍加分析就整理出整个网站的结构，但无论业务复杂程度怎样，其实道理都是一样的，一旦发现Dom元素过多或者页面行数太多，就要想到是不是应该通过结构化思维进行重构了。

![jiegou-index.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a34bd210c9ae4b418549f69c09a4681a~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=454&h=250&s=15368&e=png&b=ffffff)

    <!--重构后的首页-->
    <Header />
    <MainContent />
    <Footer />
    
    <!--MainContent内部-->
    <div>
      <Banner />
      <AboutUs />
      <ContactUs />
    </div>
    

如何提升结构化思维
---------

*   多总结

在日常看书学习时，不要看过就完事了，而是试着将学到的知识用思维导图的形式总结下来，思维导图和金字塔结构是一致的，这样既能锻炼我们结构化思维的能力，而且还能加深你对书中知识的理解，否则很容易看完就忘，不容易把学到的知识运用到实际工作生活中。

*   多写文章

写文章就是结构化表达的过程，如果思维混乱很容易写出的内容前言不搭后语。可以按照结构化的思维，先搭建文章的结构，然后再填充每个小结的内容。不要小看写作，想要把知道的内容，清晰地表达出来并不是件容易的事，试着每1-2周创作一篇文章吧。

*   模块化开发

作为前端开发，平时最多的训练计划肯定还是写代码，记得在写代码时多进行模块化、组件化开发，对于复杂功能及时拆分成几个模块进行组装，当一个文件行数超过300行，或者一个函数超过100行时，要意识到结构化开发的机会来了。

*   重视汇报材料的编写

在编写周报、月报、年终总结、邮件等汇报性资料时，要记得结论先行，以上统下，归类分组，逻辑递进，用金字塔的结构去总结、表达。